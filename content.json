{"meta":{"title":"清风逐月夜半时","subtitle":"清风逐月夜半时","description":"把努力当成一种习惯","author":"久伴沫离","url":"http://jiubanmoli.github.io"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2019-01-19T10:53:29.361Z","comments":true,"path":"about/index.html","permalink":"http://jiubanmoli.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"archives","date":"2019-01-19T10:35:16.000Z","updated":"2019-01-19T10:35:16.027Z","comments":true,"path":"archives/index.html","permalink":"http://jiubanmoli.github.io/archives/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"books","date":"2019-12-20T10:56:50.000Z","updated":"2019-12-20T12:11:26.572Z","comments":true,"path":"books/index.html","permalink":"http://jiubanmoli.github.io/books/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-01-19T10:33:32.000Z","updated":"2019-01-19T10:51:34.289Z","comments":true,"path":"categories/index.html","permalink":"http://jiubanmoli.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"movies","date":"2019-12-20T11:10:24.000Z","updated":"2019-12-20T12:27:12.442Z","comments":true,"path":"movies/index.html","permalink":"http://jiubanmoli.github.io/movies/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"要读的书","date":"2018-06-28T13:16:32.000Z","updated":"2019-01-19T15:03:51.748Z","comments":true,"path":"readBook/index.html","permalink":"http://jiubanmoli.github.io/readBook/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2019-01-19T10:34:31.000Z","updated":"2019-12-20T12:38:40.734Z","comments":true,"path":"friends/index.html","permalink":"http://jiubanmoli.github.io/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-01-19T10:33:47.000Z","updated":"2019-01-19T10:52:56.288Z","comments":true,"path":"tags/index.html","permalink":"http://jiubanmoli.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2019-12-20T09:06:36.000Z","updated":"2019-12-20T11:02:45.427Z","comments":true,"path":"contact/index.html","permalink":"http://jiubanmoli.github.io/contact/index.html","excerpt":"","text":"请在这留下你评论的脚印吧 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Hexo集成Gittalk报Error not found","slug":"gittalk-one","date":"2019-12-20T08:06:02.794Z","updated":"2022-01-04T13:58:00.068Z","comments":true,"path":"2019/12/20/gittalk-one/","link":"","permalink":"http://jiubanmoli.github.io/2019/12/20/gittalk-one/","excerpt":"","text":"最近修改个人博客评论系统，集成Gittalk，但加载Gittalk插件之后出现Error not found的情况，特此记录下解决过程： 1.在Github上面新建一个评论仓库 2.在该评论仓库中的settings设置开启issue评论 3.第三步，初始化 issues。点击issues栏，点击create an issue 4.设置GitHub Apps 的 OAuth Apps 配置项 在GitHub上注册新应用，链接：https://github.com/settings/applications/new 解释一下： 1）Application name 可以随便填一个。 2）Homepage URL 必须是博客仓库的域名（GitHub Pages 的）。 3）Authorization callback URL 必须是博客的域名（http://zyjbml.cn） 5.博客主题_config.xml配置： gitalk: enable: true owner: #Github登录名 repo: #创建的评论仓库名，例如：blog-comments oauth: clientId: #OAuth Apps的ClientID clientSecret: #OAuth Apps的Client Secret admin: #Github账号名称 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://jiubanmoli.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jiubanmoli.github.io/tags/hexo/"}]},{"title":"SpringBoot与SpringCloud的版本对应详细版","slug":"springcloud-six","date":"2019-12-17T12:01:29.746Z","updated":"2022-01-04T13:58:00.147Z","comments":true,"path":"2019/12/17/springcloud-six/","link":"","permalink":"http://jiubanmoli.github.io/2019/12/17/springcloud-six/","excerpt":"","text":"大版本对应： SpringBoot SpringCloud 1.2.x Angel版本 1.3.x Brixton版本 1.4.x stripes Camden版本 1.5.x Dalston版本、Edgware版本 2.0.x Finchley版本 2.1.x Greenwich.SR2 在实际开发过程中，我们需要更详细的版本对应 (https://start.spring.io/actuator/info)： spring官方对应查看网址：https://start.spring.io/actuator/info { \"git\":{ \"commit\":{ \"time\":\"2019-12-13T08:19:15Z\", \"id\":\"6c6e59b\" }, \"branch\":\"6c6e59b62f744ef12c2925bc6ed368fd2378ddd4\" }, \"build\":{ \"version\":\"0.0.1-SNAPSHOT\", \"artifact\":\"start-site\", \"name\":\"start.spring.io website\", \"versions\":{ \"initializr\":\"0.9.0.BUILD-SNAPSHOT\", \"spring-boot\":\"2.2.2.RELEASE\" }, \"group\":\"io.spring.start\", \"time\":\"2019-12-13T08:21:33.304Z\" }, \"bom-ranges\":{ \"azure\":{ \"2.0.10\":\"Spring Boot >=2.0.0.RELEASE and &lt;2.1.0.RELEASE\", \"2.1.7\":\"Spring Boot >=2.1.0.RELEASE and &lt;2.2.0.M1\", \"2.2.0\":\"Spring Boot >=2.2.0.M1\" }, \"codecentric-spring-boot-admin\":{ \"2.0.6\":\"Spring Boot >=2.0.0.M1 and &lt;2.1.0.M1\", \"2.1.6\":\"Spring Boot >=2.1.0.M1 and &lt;2.2.0.M1\", \"2.2.0\":\"Spring Boot >=2.2.0.M1\" }, \"spring-cloud\":{ \"Finchley.M2\":\"Spring Boot >=2.0.0.M3 and &lt;2.0.0.M5\", \"Finchley.M3\":\"Spring Boot >=2.0.0.M5 and &lt;=2.0.0.M5\", \"Finchley.M4\":\"Spring Boot >=2.0.0.M6 and &lt;=2.0.0.M6\", \"Finchley.M5\":\"Spring Boot >=2.0.0.M7 and &lt;=2.0.0.M7\", \"Finchley.M6\":\"Spring Boot >=2.0.0.RC1 and &lt;=2.0.0.RC1\", \"Finchley.M7\":\"Spring Boot >=2.0.0.RC2 and &lt;=2.0.0.RC2\", \"Finchley.M9\":\"Spring Boot >=2.0.0.RELEASE and &lt;=2.0.0.RELEASE\", \"Finchley.RC1\":\"Spring Boot >=2.0.1.RELEASE and &lt;2.0.2.RELEASE\", \"Finchley.RC2\":\"Spring Boot >=2.0.2.RELEASE and &lt;2.0.3.RELEASE\", \"Finchley.SR4\":\"Spring Boot >=2.0.3.RELEASE and &lt;2.0.999.BUILD-SNAPSHOT\", \"Finchley.BUILD-SNAPSHOT\":\"Spring Boot >=2.0.999.BUILD-SNAPSHOT and &lt;2.1.0.M3\", \"Greenwich.M1\":\"Spring Boot >=2.1.0.M3 and &lt;2.1.0.RELEASE\", \"Greenwich.SR4\":\"Spring Boot >=2.1.0.RELEASE and &lt;2.1.12.BUILD-SNAPSHOT\", \"Greenwich.BUILD-SNAPSHOT\":\"Spring Boot >=2.1.12.BUILD-SNAPSHOT and &lt;2.2.0.M4\", \"Hoxton.RELEASE\":\"Spring Boot >=2.2.0.M4 and &lt;2.2.3.BUILD-SNAPSHOT\", \"Hoxton.BUILD-SNAPSHOT\":\"Spring Boot >=2.2.3.BUILD-SNAPSHOT\" }, \"spring-cloud-services\":{ \"2.0.3.RELEASE\":\"Spring Boot >=2.0.0.RELEASE and &lt;=2.0.999.BUILD-SNAPSHOT\", \"2.1.4.RELEASE\":\"Spring Boot >=2.1.0.RELEASE\" }, \"spring-data-r2dbc\":{ \"0.1.0.M3\":\"Spring Boot >=2.2.0.M6 and &lt;2.2.3.BUILD-SNAPSHOT\", \"0.1.0.BUILD-SNAPSHOT\":\"Spring Boot >=2.2.3.BUILD-SNAPSHOT\" }, \"spring-statemachine\":{ \"2.0.0.M4\":\"Spring Boot >=2.0.0.RC1 and &lt;=2.0.0.RC1\", \"2.0.0.M5\":\"Spring Boot >=2.0.0.RC2 and &lt;=2.0.0.RC2\", \"2.0.1.RELEASE\":\"Spring Boot >=2.0.0.RELEASE\" }, \"vaadin\":{ \"10.0.17\":\"Spring Boot >=2.0.0.M1 and &lt;2.1.0.M1\", \"14.0.15\":\"Spring Boot >=2.1.0.M1\" } }, \"dependency-ranges\":{ \"okta\":{ \"1.2.1\":\"Spring Boot >=2.1.2.RELEASE and &lt;2.2.0.M1\", \"1.3.0\":\"Spring Boot >=2.2.0.M1\" }, \"mybatis\":{ \"2.0.1\":\"Spring Boot >=2.0.0.RELEASE and &lt;2.1.0.RELEASE\", \"2.1.1\":\"Spring Boot >=2.1.0.RELEASE\" }, \"geode\":{ \"1.2.2.RELEASE\":\"Spring Boot >=2.2.0.M5\" }, \"camel\":{ \"2.22.4\":\"Spring Boot >=2.0.0.M1 and &lt;2.1.0.M1\", \"2.24.2\":\"Spring Boot >=2.1.0.M1 and &lt;2.2.0.M1\", \"3.0.0\":\"Spring Boot >=2.2.0.M1\" }, \"solace\":{ \"3.1.0\":\"Spring Boot >=2.1.0.RELEASE and &lt;2.2.0.M1\", \"3.2.0\":\"Spring Boot >=2.2.0.M1\" } } } spring-cloud-dependencies 版本列表可查看： https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies spring-boot-starter-parent 版本列表可查看： https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-parent 作者：梦幻朵颜 链接：https://www.cnblogs.com/zhuwenjoyce/p/10261079.html 來源：博客园 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/tags/SpringCloud/"}]},{"title":"Linux常用命令总结","slug":"linux-one","date":"2019-12-17T11:51:31.013Z","updated":"2022-01-04T13:58:00.085Z","comments":true,"path":"2019/12/17/linux-one/","link":"","permalink":"http://jiubanmoli.github.io/2019/12/17/linux-one/","excerpt":"","text":"一、系统信息1.显示机器的处理器架构(1) arch 2.显示机器的处理器架构(2) uname -m 3.显示正在使用的内核版本 uname -r 4.显示硬件系统部件 - (SMBIOS / DMI) dmidecode -q 5.罗列一个磁盘的架构特性 hdparm -i /dev/hda 6.在磁盘上执行测试性读取操作 hdparm -tT /dev/sda 7.显示CPU info的信息 cat /proc/cpuinfo 8.显示中断 cat /proc/interrupts 9.校验内存使用 cat /proc/meminfo 10.显示哪些swap被使用 cat /proc/swaps 11.显示内核的版本 cat /proc/version 12.显示网络适配器及统计 cat /proc/net/dev 13.显示已加载的文件系统 cat /proc/mounts 14.罗列 PCI 设备 lspci -tv 15.显示 USB 设备 lsusb -tv 16.显示系统日期 date 17.显示2007年的日历表 cal 2007 18.设置日期和时间 - 月日时分年.秒 date 041217002007.00 19.将时间修改保存到 BIOS clock -w 二、关机 (系统的关机、重启以及登出 )1.关闭系统(1) shutdown -h now 2.关闭系统(2) init 0 3.关闭系统(3) telinit 0 4.按预定时间关闭系统 shutdown -h hours:minutes &amp; 5.取消按预定时间关闭系统 shutdown -c 6.重启(1) shutdown -r now 7.重启(2) reboot 8.注销 logout 三、文件和目录1.进入 ‘/ home’ 目录’ cd /home 2.返回上一级目录 cd .. 3.返回上两级目录 cd ../.. 4.进入个人的主目录 cd ~user1 5.返回上次所在的目录 cd - 6.显示工作路径 pwd 7.查看目录中的文件 ls 8.查看目录中的文件 ls -F 9.显示文件和目录的详细资料 ls -l 10.显示隐藏文件 ls -a 11.显示包含数字的文件名和目录名 ls *[0-9]* 12.显示文件和目录由根目录开始的树形结构(1) tree 13.显示文件和目录由根目录开始的树形结构(2) lstree 14.创建一个叫做 ‘dir1’ 的目录’ mkdir dir1 15.同时创建两个目录 mkdir dir1 dir2 16.创建一个目录树 mkdir -p /tmp/dir1/dir2 17.删除一个叫做 ‘file1’ 的文件’ rm -f file1 18.删除一个叫做 ‘dir1’ 的目录’ rmdir dir1 19.删除一个叫做 ‘dir1’ 的目录并同时删除其内容 rm -rf dir1 20.同时删除两个目录及它们的内容 rm -rf dir1 dir2 21.重命名/移动 一个目录 mv dir1 new_dir 22.复制一个文件 cp file1 file2 23.复制一个目录下的所有文件到当前工作目录 cp dir/*. 24.复制一个目录到当前工作目录 cp -a /tmp/dir1 . 25.复制一个目录 cp -a dir1 dir2 26.创建一个指向文件或目录的软链接 ln -s file1 lnk1 27.创建一个指向文件或目录的物理链接 ln file1 lnk1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) touch -t 0712250000 file1 29.列出已知的编码 iconv -l 四、文件搜索1.从 ‘/‘ 开始进入根文件系统搜索文件和目录 find / -name file1 2.搜索属于用户 ‘user1’ 的文件和目录 find / -user user1 3.在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件 find /home/user1 -name \\*.bin 4.搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -atime +100 5.搜索在10天内被创建或者修改过的文件 find /usr/bin -type f -mtime -10 6.搜索以 ‘.rpm’ 结尾的文件并定义其权限 find / -name \\*.rpm -exec chmod 755 '{}' \\ 7.搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备 find / -xdev -name \\*.rpm 8.寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令 locate \\*.ps 9.显示一个二进制文件、源码或man的位置 whereis halt 显示一个二进制文件或可执行文件的完整路径 which halt 五、挂载一个文件系统1.挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在 mount /dev/hda2 /mnt/hda2 2.卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出 umount /dev/hda2 3.当设备繁忙时强制卸载 fuser -km /mnt/hda2 4.运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 umount -n /mnt/hda2 5.挂载一个软盘 mount /dev/fd0 /mnt/floppy 6.挂载一个cdrom或dvdrom mount /dev/cdrom /mnt/cdrom 7.挂载一个cdrw或dvdrom mount /dev/hdc /mnt/cdrecorder 8.挂载一个cdrw或dvdrom mount /dev/hdb /mnt/cdrecorder 9.挂载一个文件或ISO镜像文件 mount -o loop file.iso /mnt/cdrom 10.挂载一个Windows FAT32文件系统 mount -t vfat /dev/hda5 /mnt/hda5 11.挂载一个usb 捷盘或闪存设备 mount /dev/sda1 /mnt/usbdisk 12.挂载一个windows网络共享 mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 六、磁盘空间1.显示已经挂载的分区列表 df -h 2.以尺寸大小排列文件和目录 ls -lSr |more 3.估算目录 ‘dir1’ 已经使用的磁盘空间’ du -sh dir1 4.以容量大小为依据依次显示文件和目录的大小 du -sk * | sort -rn 5.1n以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1 6.1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) dpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1 七、用户和群组1.创建一个新用户组 groupadd group_name 2.删除一个用户组 groupdel group_name 3.重命名一个用户组 groupmod -n new_group_name old_group_name 4.创建一个属于 “admin” 用户组的用户 useradd -c \"Name Surname \" -g admin -d /home/user1 -s /bin/bash user1 5.创建一个新用户 useradd user1 5.删除一个用户 ( ‘-r’ 排除主目录) userdel -r user1 6.修改用户属性 usermod -c \"User FTP\" -g system -d /ftp/user1 -s /bin/nologin user1 7.修改口令 passwd 8.修改一个用户的口令 (只允许root执行) passwd user1 9.设置用户口令的失效期限 chage -E 2005-12-31 user1 10.检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户 pwck 11.检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组 grpck 12.登陆进一个新的群组以改变新创建文件的预设群组 newgrp group_name 八、文件的权限 - “+” 设置权限，”-“ 用于取消1.将终端划分成5栏显示 ls /tmp | pr -T5 -W$COLUMNS 2.设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod ugo+rwx directory1 3.删除群组(g)与其他人(o)对目录的读写执行权限 chmod go-rwx directory1 4.改变一个文件的所有人属性 chown user1 file1 5.改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chown -R user1 directory1 6.改变文件的群组 chgrp group1 file1 7.改变一个文件的所有人和群组属性 chown user1:group1 file1 8.罗列一个系统中所有使用了SUID控制的文件 find / -perm -u+s 9.设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u+s /bin/file1 10.禁用一个二进制文件的 SUID位 chmod u-s /bin/file1 11.设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g+s /home/public 12.禁用一个目录的 SGID 位 chmod g-s /home/public 13.设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o+t /home/public 13.禁用一个目录的 STIKY 位 chmod o-t /home/public 九、文件的特殊属性 - “+” 设置权限，”-“ 用于取消1.只允许以追加方式读写文件 chattr +a file1 2.允许这个文件能被内核自动压缩/解压 chattr +c file1 3.在进行文件系统备份时，dump程序将忽略这个文件 chattr +d file1 4.设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +i file1 5.允许一个文件被安全地删除 chattr +s file1 6.一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +S file1 7.若文件被删除，系统会允许你在以后恢复这个被删除的文件 chattr +u file1 8.显示特殊的属性 lsattr 十、打包和压缩文件1.解压一个叫做 ‘file1.bz2’的文件 bunzip2 file1.bz2 2.压缩一个叫做 ‘file1’ 的文件 bzip2 file1 3.解压一个叫做 ‘file1.gz’的文件 gunzip file1.gz 4.压缩一个叫做 ‘file1’的文件 gzip file1 5.最大程度压缩 gzip -9 file1 6.创建一个叫做 ‘file1.rar’ 的包 rar a file1.rar test_file 7.同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’ rar a file1.rar file1 file2 dir1 8.打包rar包 rar x file1.rar 9.解压rar包 unrar x file1.rar 10.创建一个非压缩的 tarball tar -cvf archive.tar file1 11.创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件 tar -cvf archive.tar file1 file2 dir1 12.显示一个包中的内容 tar -tf archive.tar 13.释放一个包 tar -xvf archive.tar 14.将压缩包释放到 /tmp目录下 tar -xvf archive.tar -C /tmp 15.创建一个bzip2格式的压缩包 tar -cvfj archive.tar.bz2 dir1 16.解压一个bzip2格式的压缩包 tar -xvfj archive.tar.bz2 17.创建一个gzip格式的压缩包 tar -cvfz archive.tar.gz dir1 18.解压一个gzip格式的压缩包 tar -xvfz archive.tar.gz 19.创建一个zip格式的压缩包 zip file1.zip file1 20.将几个文件和目录同时压缩成一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 21.解压一个zip格式压缩包 unzip file1.zip 十一、DEB 包 (Debian, Ubuntu 类似系统)1.安装/更新一个 deb 包 dpkg -i package.deb 2.从系统删除一个 deb 包 dpkg -r package_name 3.显示系统中所有已经安装的 deb 包 dpkg -l 4.显示所有名称中包含 “httpd” 字样的deb包 dpkg -l | grep httpd 5.获得已经安装在系统中一个特殊包的信息 dpkg -s package_name 6.显示系统中已经安装的一个deb包所提供的文件列表 dpkg -L package_name 7.显示尚未安装的一个包所提供的文件列表 dpkg --contents package.deb 8.确认所给的文件由哪个deb包提供 dpkg -S /bin/ping 十二、APT 软件工具 (Debian, Ubuntu 类似系统)1.安装/更新一个 deb 包 apt-get install package_name 2.从光盘安装/更新一个 deb 包 apt-cdrom install package_name 3.升级列表中的软件包 apt-get update 4.升级所有已安装的软件 apt-get upgrade 5.从系统删除一个deb包 apt-get remove package_name 6.确认依赖的软件仓库正确 apt-get check 7.从下载的软件包中清理缓存 apt-get clean 8.返回包含所要搜索字符串的软件包名称 apt-cache search searched-package 十三、查看文件内容1.从第一个字节开始正向查看文件的内容 cat file1 2.从最后一行开始反向查看一个文件的内容 tac file1 3.查看一个长文件的内容 more file1 4.类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作 less file1 5.查看一个文件的前两行 head -2 file1 6.查看一个文件的最后两行 tail -2 file1 7.实时查看被添加到一个文件中的内容 tail -f /var/log/messages 十四、文本处理十五、字符设置和文件格式转换十六、文件系统分析十七、初始化一个文件系统十八、SWAP文件系统十九、备份二十、光盘二十一、网络 - （以太网和WIFI无线）二十二、JPS工具作者：DreamWeaver_Zhou 链接：https://blog.csdn.net/DreamWeaver_zhou/article/details/80922852 來源：CSDN document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jiubanmoli.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jiubanmoli.github.io/tags/Linux/"}]},{"title":"Git常用命令总结","slug":"git-one","date":"2019-12-17T10:42:45.282Z","updated":"2022-01-04T13:58:00.070Z","comments":true,"path":"2019/12/17/git-one/","link":"","permalink":"http://jiubanmoli.github.io/2019/12/17/git-one/","excerpt":"","text":"一、新建代码库1.新建一个项目，并初始化 $ git init [project-name] 2.下载项目 $ git clone [url] 二、配置1.显示当前的Git配置 $ git config --list 2.编辑Git配置文件 $ git config -e [--global] 3.设置提交代码时的用户信息 $ git config [--global] user.name \"name\" $ git config [--global] user.email \"email.adress\" 三、增加/删除文件1.添加指定文件到暂存区 $ git add [file1][file2].... 2.添加指定目录到暂存区包括子目录 $ git add [dir] 3.添加当前目录的所有文件到暂存区 $ git add . 4.添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交 $ git add -p 5.删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1][file2]... 6.停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] 7.改名文件，并将这个改名放入暂存区 $ git mv [file-original][file-renamed] 四、代码提交1.提交暂存区到仓库区 $ git commit -m [message] 2.提交暂存区的指定文件到仓库区 $ git commit [file1] [file2].... -m [message] 3.提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a 4.提交时显示所有的diff信息 $ git commit -v 5.使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] 6.重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 五、分支1.列出本地所有分支 $ git branch 2.列出所有远程分支 $ git branch -r 3.列出所有本地分支和远程分支 $ git branch -a 4.新建一个分支，但依然停留在当前分支 $ git branch [branch-name] 5.新建一个分支，并切换到该分支 $ git checkout -b [branch] 6.新建一个分支，指定指向commit $ git branch [branch] [commit] 7.新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] 8.切换到指定分支，并更新工作区 $ git checkout [branch-name] 9.切换到上一个分支 $ git checkout - 10.建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] 11.合并指定分支到当前分支 $ git merge [branch] 12.选择一个commit，合并进当前分支 $ git cherry-pick [commit] 13.删除分支 $ git branch -d [branch-name] 14.删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 六、标签1.列出所有的tag $ git tag 2.新建一个tag，在当前commit $ git tag [tag] 3.新建一个tag在指定commit $ git tag [tag] [commit] 4.删除本地tag $ git tag -d [tag] 5.删除远程tag $ git push origin :refs/tags/[tagName] 6.查看tag信息 $ git show [tag] 7.提交指定tag $ git push [remote] [tag] 8.提交所有tag $ git push [remote] --tags 9.新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 七、查看信息1.显示有变更的文件 $ git status 2.显示当前分支的版本历史 $ git log 3.显示commit历史，以及每次commit发生变更的文件 $ git log --stat 4.搜索提交历史，根据关键词 $ git log -S [keyword] 5.显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s 6.显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 $ git log [tag] HEAD --grep feature 7.显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] 8.显示指定文件相关的每一次diff $ git log -p [file] 9.显示过去的5次提交 $ git log -5 --pretty --oneline 10.显示所有提交过的用户，按提交次数排序 $ git shortlog -sn 11.显示指定文件是什么人在什么时间修改过 $ git blame [file] 12.显示暂存区和工作区的差异 $ git diff 13.显示暂存区和上一个commit的差异 $ git diff --cached [file] 14.显示工作区与当前分支最新commit之间的差异 $ git diff HEAD 15.显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] 16.显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" 17.显示某次提交的元数据和内容变化 $ git show [commit] 18.显示某次提交发生变化的文件 $ git show --name-only [commit] 19.显示某次提交时，某个文件的内容 $ git show [commit]:[filename] 20.显示当前分支的最近几次提交 $ git reflog 八、远程同步1.下载远程仓库的所有变动 $ git fetch [remote] 2.显示所有远程仓库 $ git remote -v 3.显示某个远程仓库的信息 $ git remote show [remote] 4.增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] 5.取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] 6.上传本地指定分支到远程仓库 $ git push [remote] [branch] 7.强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force 8.推送所有分支到远程仓库 $ git push [remote] --all 九、撤销1.恢复暂存区的指定文件到工作区 $ git checkout [file] 2.恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] 3.恢复暂存区的所有文件到工作区 $ git checkout . 4.重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] 5.重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard 6.重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] 7.重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] 8.重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] 9.新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 10.暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 十、其他1.生成一个可供发布的压缩包 $ git archive 作者：190cm 链接：https://juejin.im/post/5dadb9f3e51d4526cc28135f 來源：掘金 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Git","slug":"Git","permalink":"http://jiubanmoli.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://jiubanmoli.github.io/tags/Git/"}]},{"title":"认识SpringCloud(五)—常用配置详解","slug":"springcloud-five","date":"2019-12-16T12:17:04.656Z","updated":"2022-01-04T13:58:00.134Z","comments":true,"path":"2019/12/16/springcloud-five/","link":"","permalink":"http://jiubanmoli.github.io/2019/12/16/springcloud-five/","excerpt":"","text":"一、Eureka 属性名 说明 默认值 eureka.server.enable-self-preservation 关闭注册中心的保护机制，Eureka 会统计15分钟之内心跳失败的比例低于85%将会触发保护机制，不剔除服务提供者，如果关闭服务注册中心将不可用的实例正确剔除 false eureka.instance.prefer-ip-address 不使用主机名来定义注册中心的地址，而使用IP地址的形式，如果设置eureka.instance.ip-address 属性，则使用该属性配置的IP，否则自动获取除环路IP外的第一个IP地址 eureka.instance.ip-address IP地址 eureka.instance.hostname 设置当前实例的主机名称 eureka.instance.lease-renewal-interval-in-seconds 定义服务续约任务（心跳）的调用间隔，单位：秒 30 eureka.instance.lease-expiration-duration-in-seconds 定义服务失效的时间，单位：秒 90 eureka.instance.status-page-url-path 状态页面的URL，相对路径，默认使用 HTTP 访问，如果需要使用 HTTPS则需要使用绝对路径配置 /info eureka.instance.status-page-url 状态页面的URL，绝对路径 eureka.instance.health-check-url-path 健康检查页面的URL，相对路径，默认使用 HTTP 访问，如果需要使用 HTTPS则需要使用绝对路径配置 /health eureka.client.service-url 指定服务注册中心地址，类型为 HashMap，并设置有一组默认值，默认的Key为 defaultZone；如果服务注册中心为高可用集群时，多个注册中心地址以逗号分隔如果服务注册中心加入了安全验证，这里配置的地址格式为： http://:@localhost:8761/eureka 其中 为安全校验的用户名； 为该用户的密码 http://localhost:8761/eureka eureka.client.fetch-registery 检索服务 true eureka.client.registery-fetch-interval-seconds 从Eureka服务器端获取注册信息的间隔时间，单位：秒 30 eureka.client.allow-redirects 指示服务器是否可以将客户端请求重定向到备份服务器/集群 false eureka.client.availability-zones 获取此实例所在区域的可用性区域列表 eureka.client.backup-registry-impl 获取执行BackupRegistry的实现的名称 eureka.client.cache-refresh-executor-exponential-back-off-bound 缓存刷新执行者指数退出相关属性 10 eureka.client.cache-refresh-executor-thread-pool-size cacheRefreshExecutor初始化的线程池大小 2 eureka.client.client-data-accept EurekaAccept客户端数据接受名称 eureka.client.disable-delta 指示eureka客户端是否应该禁用提取delta false eureka.client.dollar-replacement 在eureka服务器的序列化/反序列化信息期间，获取Dollar符号$ &lt;/ code&gt;的替换字符串 _ eureka.client.enabled 标记是否启用Eureka客户端 true eureka.client.escape-char-replacement 在eureka服务器的序列化/反序列化信息期间获取下划线符号_&lt;/ code&gt;的替换字符串 __ eureka.client.eureka-connection-idle-timeout-seconds 表示到eureka服务器的HTTP连接可以在关闭之前保持空闲状态的时间（以秒为单位） 30 eureka.client.eureka-server-connect-timeout-seconds 指示在连接到eureka服务器需要超时之前等待（以秒为单位）的时间 5 eureka.client.eureka-server-d-n-s-name 获取要查询的DNS名称以获取eureka服务器的列表 eureka.client.eureka-server-port 获取用于构建服务url的端口 eureka.client.eureka-server-read-timeout-seconds 指示从eureka服务器读取之前需要等待（秒）多久才能超时 8 eureka.client.eureka-server-total-connections 获取从eureka客户端到所有eureka服务器允许的总连接数 200 eureka.client.eureka-server-total-connections-per-host 获取从eureka客户端到eureka服务器主机允许的总连接数 50 eureka.client.eureka-server-u-r-l-context 获取用于构建服务网址的URL上下文，以便在eureka服务器列表来自DNS时联系eureka服务器 eureka.client.eureka-service-url-poll-interval-seconds 表示轮询对eureka服务器信息进行更改的频率（以秒为单位） 0 eureka.client.fetch-registry 指示该客户端是否应从eureka服务器获取eureka注册表信息 true eureka.client.fetch-remote-regions-registry 逗号分隔将获取eureka注册表信息的区域列表 eureka.client.filter-only-up-instances 指示是否在仅具有InstanceStatus UP状态的实例的过滤应用程序之后获取应用程序 true eureka.client.g-zip-content 从服务器支持时，是否必须压缩从eureka服务器提取的内容 true eureka.client.heartbeat-executor-exponential-back-off-bound 心跳执行者指数回撤相关财产 10 eureka.client.heartbeat-executor-thread-pool-size heartbeat执行器初始化的线程池大小 2 eureka.client.initial-instance-info-replication-interval-seconds 指示将实例信息复制到eureka服务器的开始时间（以秒为单位） 40 eureka.client.instance-info-replication-interval-seconds 指示复制要复制到eureka服务器的实例更改的频率（以秒为单位） 30 eureka.client.log-delta-diff 指示在注册表信息方面是否记录eureka服务器和eureka客户端之间的差异 false eureka.client.on-demand-update-status-change 如果设置为true，则通过ApplicationInfoManager进行的本地状态更新将触发对远程eureka服务器的按需（但限速）注册/更新 true eureka.client.prefer-same-zone-eureka 指示此实例是否应尝试在同一区域中使用eureka服务器延迟和/或其他原因 eureka.client.proxy-host 获取代理主机到eureka服务器（如果有的话） eureka.client.proxy-password 获取代理密码（如果有） eureka.client.proxy-port 获取代理端口到eureka服务器（如果有的话） eureka.client.proxy-user-name 获取代理用户名（如果有） eureka.client.region us-east-1 获取此实例所在的区域 eureka.client.register-with-eureka 指示此实例是否应将其信息注册到eureka服务器以供其他人发现 true eureka.client.registry-fetch-interval-seconds 指示从eureka服务器获取注册表信息的频率（以秒为单位） 30 eureka.client.registry-refresh-single-vip-address 指示客户端是否只对单个VIP的注册表信息感兴趣 eureka.client.service-url 可用性区域映射到与eureka服务器通信的完全限定URL的列表。每个值可以是单个URL或逗号分隔的替代位置列表 eureka.client.use-dns-for-fetching-service-urls 指示eureka客户端是否应该使用DNS机制来获取要与之通信的eureka服务器列表。 false eureka.dashboard.enabled 标志以启用Eureka仪表板 true eureka.dashboard.path 到Eureka仪表板（相对于servlet路径）的路径 “/” eureka.instance.a-s-g-name 获取与此实例关联的AWS自动缩放组名称。 eureka.instance.app-group-name 获取要在eureka中注册的应用程序组的名称 eureka.instance.appname 获取要在eureka注册的应用程序的名称 unknown eureka.instance.data-center-info 返回此实例部署的数据中心 eureka.instance.health-check-url 获取此实例的绝对运行状况检查页面URL 二、Feign 属性名 说明 默认值 feign.compression.request.mime-types 支持的MIME类型列表 [text/xml, application/xml, application/json] feign.compression.request.min-request-size 最小阈值内容大小 2048 三、health 属性名 说明 默认值 health.config.enabled 标记以指示应安装配置服务器运行状况指示器 false health.config.time-to-live 生成缓存结果的时间，以毫秒为单位 300000（5分钟） 四、hystrix 属性名 说明 默认值 hystrix.metrics.enabled 启用Hystrix指标轮询 true hystrix.metrics.polling-interval-ms 后续轮询度量之间的间隔 2000 五、hystrix 属性名 说明 默认值 zuul.add-host-header 标识以确定代理是否转发主机头 false zuul.add-proxy-headers 标识以确定代理是否添加X-Forwarded-* 标头 true zuul.host.max-per-route-connections 单个路由可以使用的最大连接数 20 zuul.host.max-total-connections 代理可以容纳到后端的总连接数 200 zuul.ignore-security-headers 如果spring security在类路径上，则将SECURITY_HEADERS添加到忽略的标头 true zuul.ignored-headers HTTP标头的名称完全忽略 zuul.ignored-services 一组服务名称不考虑代理自动。 zuul.prefix 所有路由的公共前缀 zuul.remove-semicolon-content 标记说，可以删除超过第一个分号的路径元素 zuul.retryable 默认情况下是否支持重试的标志 zuul.routes 将路线名称映射到属性 zuul.securityheaders 一般预期由Spring安全性添加的标头，因此如果代理和后端使用Spring保护，则通常会重复。默认情况下，如果存在Spring安全性，并且ignoreSecurityHeaders = true，它们将被添加到忽略的标头 zuul.semaphore.max-semaphores Hystrix的总信号量的最大数量 100 zuul.sensitive-headers 不传递到下游请求的敏感标头列表 zuul.servlet-path 安装Zuul作为servlet的路径 /zull zuul.ssl-hostname-validation-enabled 标记以说明是否应验证ssl连接的主机名 true zuul.strip-prefix 在转发之前标记是否从路径中删除前缀 true zuul.trace-request-body 标记说可以跟踪请求机构 六、spring.cloud.bus 属性名 说明 默认值 spring.cloud.bus.ack.destination-service 想要听ack的服务 null（表示所有服务） spring.cloud.bus.ack.enabled 标志关闭acks true spring.cloud.bus.destination 名称Spring Cloud消息的流目的地 springCloudBus spring.cloud.bus.enabled 标志表示总线已启用 true spring.cloud.bus.env.enabled 标志关闭环境变化事件 true spring.cloud.bus.refresh.enabled 关闭刷新事件的标志 true spring.cloud.bus.trace.enabled 打开acks跟踪的标志 false 七、spring.cloud.config 属性名 说明 默认值 spring.cloud.config.allow-override 标记以指示可以使用{@link #isSystemPropertiesOverride（）systemPropertiesOverride}。设置为false以防止用户意外更改默认值 true spring.cloud.config.authorization 客户端使用的授权令牌连接到服务器 spring.cloud.config.discovery.enabled 标记以指示启用配置服务器发现 false spring.cloud.config.discovery.service-id 服务ID来定位配置服务器 configserver spring.cloud.config.enabled 标记说远程配置启用 true spring.cloud.config.fail-fast 标记表示无法连接到服务器是致命的 false spring.cloud.config.label 用于拉取远程配置属性的标签名称 spring.cloud.config.name 用于获取远程属性的应用程序名称 spring.cloud.config.override-none 标志表示当{@link #setAllowOverride（boolean）allowOverride}为true时，外部属性应该采用最低优先级，并且不覆盖任何现有的属性源（包括本地配置文件） false spring.cloud.config.override-system-properties 标记以指示外部属性应覆盖系统属性 true spring.cloud.config.password 联系远程服务器时使用的密码 spring.cloud.config.profile 获取远程配置时使用的默认配置文件（逗号分隔） default spring.cloud.config.retry.initial-interval 初始重试间隔（以毫秒为单位） 1000 spring.cloud.config.retry.max-attempts 最大尝试次数 6 spring.cloud.config.retry.max-interval 退避的最大间隔 2000 spring.cloud.config.retry.multiplier 下一个间隔的乘数 1.1 spring.cloud.config.server.bootstrap 表示配置服务器应使用远程存储库中的属性初始化其自己的环境 false spring.cloud.config.server.default-application-name application 传入请求没有特定的默认应用程序名称 application spring.cloud.config.server.default-label 传入请求没有特定标签时的默认存储库标签 spring.cloud.config.server.default-profile 传入请求没有特定的默认应用程序配置文件时 default spring.cloud.config.server.encrypt.enabled 在发送给客户端之前启用对环境属性的解密 true spring.cloud.config.server.git.force-pull 标记表示存储库应该强制拉。如果真的丢弃任何本地更改并从远程存储库获取 spring.cloud.config.server.git.password 使用远程存储库验证密码 spring.cloud.config.server.git.repos 存储库标识符映射到位置和其他属性 spring.cloud.config.server.git.search-paths 在本地工作副本中使用的搜索路径 spring.cloud.config.server.git.timeout 用于获取HTTP或SSH连接的超时（以秒为单位） 5 spring.cloud.config.server.git.uri 远程存储库的URI spring.cloud.config.server.git.username 用于远程存储库的身份验证用户名 spring.cloud.config.server.native.fail-on-error 标识以确定在解密期间如何处理异常 false spring.cloud.config.server.native.search-locations 搜索配置文件的位置 [] spring.cloud.config.server.native.version 为本地存储库报告的版本字符串 spring.cloud.config.server.overrides 无条件发送给所有客户的资源的额外地图 spring.cloud.config.server.prefix 配置资源路径的前缀 spring.cloud.config.server.strip-document-from-yaml 标记为指示作为文本或集合（而不是映射）的YAML文档应以“本机”形式返回 true spring.cloud.config.uri 远程服务器的URI http：// localhost：8888 spring.cloud.config.username 联系远程服务器时使用的用户名 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/tags/SpringCloud/"}]},{"title":"认识SpringCloud(四)—服务治理机制","slug":"springcloud-four","date":"2019-12-16T11:17:58.008Z","updated":"2022-01-04T13:58:00.136Z","comments":true,"path":"2019/12/16/springcloud-four/","link":"","permalink":"http://jiubanmoli.github.io/2019/12/16/springcloud-four/","excerpt":"","text":"一、了解服务治理机制在上一节搭建SpringCloud中，我们知道了整个 Eureka 服务治理基础架构的三个核心要素。下面我们进一步了解下SpringCloud的服务治理机制 我们看可以先看下图： 根据上面的结构， 下面我们来详细了解一下， 从服务注册开始到服务调用， 及各个元素所涉及的一些重要通信行为。 二、服务提供者服务提供者有服务注册、服务同步、服务续约。 服务注册： “服务提供者” 在启动的时候会通过发送REST请求的方式将自己注册到EurekaServer上， 同时带上了自身服务的一些元数据信息。 在服务注册时， 需要确认一下eureka.client.register-with-eureka=true参数是否正确， 该值默认为true。 若设置为false将不会启动注册操作。 服务同步： 当服务提供者发送注册请求到一个服务注册中心时， 它会将该请求转发给集群中相连的其他注册中心， 从而实现注册中心之间的服务同步。 服务续约： 在注册完服务之后，服务提供者会维护一个心跳用来持续告诉EurekaSe1-ver: “我还活着”， 以防止Eureka Server的“剔除任务 ” 将该服务实例从服务列表中排除出去，我们称该操作为服务续约(Renew)。 eureka.instance.lease-renewal-interval-in-seconds 参数用于定义服务续约任务的调用间隔时间，默认为30秒。 eureka.instance.lease-expira巨ondura已on-in-seconds参数用于定义服务失效的时间，默认为90秒。 三、服务消费者服务消费者有获取服务、服务调用、服务下线。 获取服务： 启动服务消费者的时候，会发送一个REST请求到注册中心，获取注册的服务清单。 必须确保eureka.c巨ent.fetch-registry= true参数设置为true 可以修改缓存清单的更新时间，设置过eureka.client.registry-fetch-interval-seconds= 30,单位为秒 服务调用： 服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。 服务下线： 以在客户端程序中， 当服务实例进行正常的关闭操作时， 它会触发一个服务下线的REST请求给Eureka Server, 告诉服务注册中心：“我要下线了”。 服务端在接收到请求之后，该服务状态置为下线(DOWN), 并把该下线事件传播出去。 四、服务注册中心服务注册中心有失效剔除、自我保护。 失效剔除： 由于内存溢出、 网络故障等原因使得服务不能正常工作， 而服务注册中心并未收到 “服务下线” 的请求。 解决办法：在启动的时候会创建一个定时任务，默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）没有续约的服务剔除出去。 自我保护： 客户端必须要有容错机制， 比如可以使用请求重试、断路器等机制，避免出现调用失败的情况。本地调试很容易出发自我保护机制。 解决办法：以使用eureka.server.enableself-preservation = false来关闭自我保护机制，以确保注册中心可以将不可用的实例正确剔除。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/tags/SpringCloud/"}]},{"title":"认识SpringCloud(三)—服务注册中心SpringCloud Eureka","slug":"springcloud-three","date":"2019-12-16T07:48:57.716Z","updated":"2022-01-04T13:58:00.145Z","comments":true,"path":"2019/12/16/springcloud-three/","link":"","permalink":"http://jiubanmoli.github.io/2019/12/16/springcloud-three/","excerpt":"","text":"一、认识服务治理服务治理： 主要用来实现各个微服务实例的自动化注册与发现。 例如画几个简图来帮忙理解 项目A调用项目B，正常调用项目A请求项目B 有了服务中心之后，任何一个服务都不能直接去掉用，都需要通过服务中心来调用 项目A调用项目B，项目B在调用项目C 这时候调用的步骤就会为两步：第一步，项目A首先从服务中心请求项目B服务器，然后项目B在从服务中心请求项目C服务。 二、认识Eureka按照官方介绍： Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers. Eureka 是一个基于 REST 的服务，主要在 AWS 云中使用, 定位服务来进行中间层服务器的负载均衡和故障转移。 Eureka由两个组件组成：Eureka服务器和Eureka客户端。 Eureka服务器:用作服务注册服务器。 Eureka客户端:是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。 Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。 上图简要描述了Eureka的基本架构，由3个角色组成： 1、Eureka Server 提供服务注册和发现 2、Service Provider 服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到 3、Service Consumer 服务消费方从Eureka获取注册服务列表，从而能够消费服务 三、搭建服务注册中心1.首先，创建一个基础的Spring Boot工程，创建一个Eureka注册中心，命名为eureka-server, 并在pom.xml中引入必要的依赖内容， 代码如下： &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-hystrix&lt;/artifactId> &lt;/dependency> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>Hoxton.RELEASE&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;repositories> &lt;repository> &lt;id>spring-milestones&lt;/id> &lt;name>Spring Milestones&lt;/name> &lt;url>https://repo.spring.io/milestone&lt;/url> &lt;/repository> &lt;/repositories> 2.配置application.yml文件： server: port: 8081 eureka: instance: hostname: eurka-server client: #表示是否将自己注册到Eureka Server，默认为true。 register-with-eureka: false #表示是否从Eureka Server获取注册信息，默认为true。 fetch-registry: false #设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址 service-url: defaultZone: http://localhost:8081/eureka/ 3.在启动类添加@EnableEurekaServer注解，如下： @EnableEurekaServer @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 4.启动工程后，访问：http://localhost:8081/， 可以看到下面的页面，其中还没有发现任何服务 四、创建服务提供者1.pom.xml配置如下： &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;version>2.0.0.RELEASE&lt;/version> &lt;/dependency> 2.配置application.xml, server: port: 8082 eureka: instance: hostname: eurka-server2 client: service-url: defaultZone: http://localhost:8081/eureka/ 3.启动类添加如下注解: @SpringBootApplication @EnableEurekaClient public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 4.最后，将两个项目打成jar包，通过cmd命令启动如下： 5.查看服务中心注册页面，便可看到相对应的服务已经注册到注册中心了。 五、创建服务消费者1.pom.xml配置和服务提供者一样 2.application.xml server: port: 8083 spring: application: name: consumer-user eureka: instance: hostname: eurka-server3 client: service-url: defaultZone: http://localhost:8081/eureka/ 3.启动类添加@EnableDiscoveryClient注解 @EnableDiscoveryClient @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 4.注册中心可以查看服务消费者： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/tags/SpringCloud/"}]},{"title":"认识SpringCloud(二)","slug":"springcloud-two","date":"2019-12-16T07:35:19.473Z","updated":"2022-01-04T13:58:00.141Z","comments":true,"path":"2019/12/16/springcloud-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/12/16/springcloud-two/","excerpt":"","text":"一、搭建SpringBoot项目1.打开idea窗口，选择File--&gt;New--&gt;Project--&gt;Spring Initializr,Project SDK为1.8,点击Next按钮，填写Group，Artifact,选择Packaging打包类型是Jar包还是war包，填写包名，点击Next，可以选择相对应的依赖，点击Next按钮，选择项目创建的地址和项目名称，点击Finish. 2.新建HelloController,内容如下： @RestController public class HelloController{ @RequestMapping(\"/hello\") public String index(){ return \"Hello Word\"; } } 3.访问浏览器http://localhost:8080/hello, 就能看到返回结果 二、初识actuator能够自动为Spring Boot构建的应用提供 一系列用千监控的端点。 POM.xml添加如下依赖： &lt;dependeny> &lt;groupId>org.springframwork.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId> &lt;/dependeny> 启动，访问/health断点，返回如下信息： { \"status\":\"UP\" } 原生端点： 应用配置类： 获取应用程序中加载的应用配置、环境变量、自动化配置报告等配置类信息 度量指标类： 获取应用程序运行过程中用于监控的度量指标，比如内存信息、线程池信息、HTTP请求统计 操作控制类： 提供了对应用的关闭等操作类功能 应用配置类： /autoconfig: 用来获取应用的自动化配置报告 positiveMatches：返回条件匹配成功的自动化配置 negativeMatches: 返回条件匹配不成功的自动化配置 /beans: 用来获取应用上下文中创建的所有Bean bean: Bean的名称 scope: Bean的作用域 type： Bean的JAVA类型 resource： class文件的具体路径 dependencies: 依赖的Bean名称 /configprops: 用来获取配置的属性信息报告 /env: 用来获取应用所有可用的环境属性报告，包括环境变量、JVM属性、应用的配置属性、命令行参数 /mappings: 返回所有Spring MVC的控制器映射关系报告 /info: 返回一些应用自定义的信息 度量指标类： /metrics: 返回当前应用的各类重要度量指标，比如内存信息、线程信息、垃圾回收信息等 /health: 获取各类健康指标信息 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/tags/SpringCloud/"}]},{"title":"认识SpringCloud(一)","slug":"springcloud-one","date":"2019-12-16T06:25:23.271Z","updated":"2022-01-04T13:58:00.138Z","comments":true,"path":"2019/12/16/springcloud-one/","link":"","permalink":"http://jiubanmoli.github.io/2019/12/16/springcloud-one/","excerpt":"","text":"一、什么是微服务架构主要是将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自的进程中运行，服务之间通过基于HTTP的RESTFUL API进行通信协作 什么是RESTFUL？ 简单来说就是用URL定位资源，用HTTP描述操作 二、微服务架构的调用方式1.使用HTTP的RESTFUL API或轻量级的消息发送协议，实现信息传递与服务调用的触发2.通过在轻量级消息总线上传递消息，类似RabbitMQ等一些提供可靠异步交换的中间件 三、SpringCloud的优点 提供配置管理 服务治理 断路器 智能路由 微代理 控制总线 全局锁 决策竞选 分布式会话 集群状态管理 ….. 四、SpringCloud相关组件 SpringCloud Config: 配置管理工具 SpringCloud Netflix: 核心组件 Eureka: 服务注册中心、服务注册与发现机制的实现 Hystrix: 容错管理组件 Ribbon: 客户端负载均衡的服务调用组件 Feign: 声明式调用组件 Zuul: 网管组件，提供智能路由、访问过滤等功能 SpringCloud Bus: 事件、消息总线 SpringCloud Cluster: 针对Zookeeper、Redis的选举算法和通用状态模式的实现 SpringCloud Consul: 服务发现与配置管理工具 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://jiubanmoli.github.io/tags/SpringCloud/"}]},{"title":"spring-boot-kafka启动报错,无法自动创建Topic","slug":"springboot-six","date":"2019-11-28T11:18:51.326Z","updated":"2022-01-04T13:58:00.127Z","comments":true,"path":"2019/11/28/springboot-six/","link":"","permalink":"http://jiubanmoli.github.io/2019/11/28/springboot-six/","excerpt":"","text":"之前用SpringBoot集成Kafka的时候，后面运行就报一下错误： Caused by: java.lang.IllegalStateException: Topic(s) [topic2, topic3] is/are not present and missingTopicsFatal is true at org.springframework.kafka.listener.AbstractMessageListenerContainer.checkTopics(AbstractMessageListenerContainer.java:351) ~[spring-kafka-2.3.0.RC1.jar:2.3.0.RC1] at org.springframework.kafka.listener.ConcurrentMessageListenerContainer.doStart(ConcurrentMessageListenerContainer.java:136) ~[spring-kafka-2.3.0.RC1.jar:2.3.0.RC1] at org.springframework.kafka.listener.AbstractMessageListenerContainer.start(AbstractMessageListenerContainer.java:308) ~[spring-kafka-2.3.0.RC1.jar:2.3.0.RC1] at org.springframework.kafka.config.KafkaListenerEndpointRegistry.startIfNecessary(KafkaListenerEndpointRegistry.java:309) ~[spring-kafka-2.3.0.RC1.jar:2.3.0.RC1] at org.springframework.kafka.config.KafkaListenerEndpointRegistry.start(KafkaListenerEndpointRegistry.java:256) ~[spring-kafka-2.3.0.RC1.jar:2.3.0.RC1] at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:182) ~[spring-context-5.2.0.BUILD-SNAPSHOT.jar:5.2.0.BUILD-SNAPSHOT] ... 14 common frames omitted 经过排查和寻找方案，才知道原因，我的Kafka版本是2.3.1，凡是2.2版本以上的，都添加了一个新的属性missingTopicsFatal，需要设置成false 因此需要在application.yml文件这样设置一下就Ok了 kafka: producer: bootstrap-servers: localhost:9092 consumer: bootstrap-servers: localhost:9092 group-id: info enable-auto-commit: true auto-offset-reset: latest template: default-topic: info listener: missing-topics-fatal: false document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jiubanmoli.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jiubanmoli.github.io/tags/SpringBoot/"}]},{"title":"spring boot项目打包成war并在tomcat上运行的步骤","slug":"springboot-five","date":"2019-11-25T14:17:44.114Z","updated":"2022-01-04T13:58:00.124Z","comments":true,"path":"2019/11/25/springboot-five/","link":"","permalink":"http://jiubanmoli.github.io/2019/11/25/springboot-five/","excerpt":"","text":"一、修改打包形式在pom.xml里设置 &lt;packaging>war&lt;/packaging> 二、移除嵌入式tomcat插件在pom.xml里找到spring-boot-starter-web依赖节点，在其中添加如下代码， &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;!-- 移除嵌入式tomcat插件 --> &lt;exclusions> &lt;exclusion> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-tomcat&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> 三、添加servlet-api的依赖下面两种方式都可以，任选其一 &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>javax.servlet-api&lt;/artifactId> &lt;version>3.1.0&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.tomcat&lt;/groupId> &lt;artifactId>tomcat-servlet-api&lt;/artifactId> &lt;version>8.0.36&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> 四、修改启动类，并重写初始化方法我们平常用main方法启动的方式，都有一个App的启动类，代码如下： @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 我们需要类似于web.xml的配置方式来启动spring上下文了，在Application类的同级添加一个SpringBootStartApplication类，其代码如下: /** * 修改启动类，继承 SpringBootServletInitializer 并重写 configure 方法 */ public class SpringBootStartApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { // 注意这里要指向原先用main方法执行的Application启动类 return builder.sources(Application.class); } } 五、打包部署在项目根目录下（即包含pom.xml的目录），在命令行里输入：mvn clean package即可， 等待打包完成，出现[INFO] BUILD SUCCESS即为打包成功。然后把target目录下的war包放到tomcat的webapps目录下，启动tomcat，即可自动解压部署。 注意事项： 使用外部Tomcat部署访问的时候，application.properties(或者application.yml)中配置的 server.port= server.servlet.context-path= 将失效，请使用tomcat的端口，tomcat，webapps下项目名进行访问。 为了防止应用上下文所导致的项目访问资源加载不到的问题， 建议pom.xml文件中&lt;build&gt;&lt;/build&gt;标签下添加&lt;finalName&gt;&lt;/finalName&gt;标签 最后在浏览器中输入http://localhost:[端口号]/[打包项目名]/ 作者：平凡的LU同学 链接：https://blog.csdn.net/yalishadaa/article/details/70037846 來源：CSDN document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jiubanmoli.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jiubanmoli.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot yml文件自定义属性乱码","slug":"springboot-four","date":"2019-11-25T05:55:24.999Z","updated":"2022-01-04T13:58:00.126Z","comments":true,"path":"2019/11/25/springboot-four/","link":"","permalink":"http://jiubanmoli.github.io/2019/11/25/springboot-four/","excerpt":"","text":"在springboot的application.yml文件中有中文时，读取出来的是乱码，需要进行一下操作： 将idea的配置编码设置为UTF-8,步骤如下： 1.Files-&gt;Editor-&gt;File Encodings,设置Global Encoding,Project Encoding和Default Encoding for Properties files编码为UTF-8 2.修改application.yml配置如下： server: port: 8081 tomcat: uri-encoding: UTF-8 spring: http: encoding: charset: utf-8 enabled: true force: true messages: encoding: UTF-8 然后在应用就ok了。 作者：gnail_oug 链接：https://blog.csdn.net/gnail_oug/article/details/80111787 來源：CSDN document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jiubanmoli.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jiubanmoli.github.io/tags/SpringBoot/"}]},{"title":"hexo打包报TypeError Cannot read property 'count' of undefined","slug":"hexo-one","date":"2019-11-24T10:45:09.862Z","updated":"2022-01-04T13:58:00.071Z","comments":true,"path":"2019/11/24/hexo-one/","link":"","permalink":"http://jiubanmoli.github.io/2019/11/24/hexo-one/","excerpt":"","text":"某一天，突然想将自己的博客文章发布打包项目时，报如下错误： $ hexo g INFO Start processing FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html TypeError: Cannot read property 'count' of undefined at Hexo.module.exports (E:\\github\\hexo\\node_modules\\hexo-baidu-url-submit\\lib\\generator.js:4:40) at Hexo.tryCatcher (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Hexo. (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\method.js:15:34) at E:\\github\\hexo\\node_modules\\hexo\\lib\\hexo\\index.js:337:24 at tryCatcher (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\util.js:16:23) at MappingPromiseArray._promiseFulfilled (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\map.js:61:38) at MappingPromiseArray.PromiseArray._iterate (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:113:31) at MappingPromiseArray.init (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:77:10) at MappingPromiseArray._asyncInit (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\map.js:30:10) at Async._drainQueue (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\async.js:138:12) at Async._drainQueues (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\async.js:143:10) at Immediate.Async.drainQueues (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\async.js:17:14) at runCallback (timers.js:649:20) at tryOnImmediate (timers.js:622:5) at processImmediate [as _immediateCallback] (timers.js:594:5) FATAL Cannot read property 'count' of undefined TypeError: Cannot read property 'count' of undefined at Hexo.module.exports (E:\\github\\hexo\\node_modules\\hexo-baidu-url-submit\\lib\\generator.js:4:40) at Hexo.tryCatcher (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Hexo. (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\method.js:15:34) at E:\\github\\hexo\\node_modules\\hexo\\lib\\hexo\\index.js:337:24 at tryCatcher (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\util.js:16:23) at MappingPromiseArray._promiseFulfilled (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\map.js:61:38) at MappingPromiseArray.PromiseArray._iterate (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:113:31) at MappingPromiseArray.init (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:77:10) at MappingPromiseArray._asyncInit (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\map.js:30:10) at Async._drainQueue (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\async.js:138:12) at Async._drainQueues (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\async.js:143:10) at Immediate.Async.drainQueues (E:\\github\\hexo\\node_modules\\bluebird\\js\\release\\async.js:17:14) at runCallback (timers.js:649:20) at tryOnImmediate (timers.js:622:5) at processImmediate [as _immediateCallback] (timers.js:594:5) 原因：安装了百度推送的插件导致 话不多说，解决方案如下： 运行如下指令 1.npm remove hexo-baidu-url-submit 2.hexo clean 3.hexo g document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"hexo","slug":"hexo","permalink":"http://jiubanmoli.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jiubanmoli.github.io/tags/hexo/"}]},{"title":"SpringBoot 2.0启动报No active profile set, falling back to default","slug":"springboot-three","date":"2019-11-24T07:03:02.978Z","updated":"2022-01-04T13:58:00.132Z","comments":true,"path":"2019/11/24/springboot-three/","link":"","permalink":"http://jiubanmoli.github.io/2019/11/24/springboot-three/","excerpt":"","text":"创建一个SpringBoot项目之后，控制台打印如下： . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.1.1.RELEASE) 2019-01-09 21:10:41.812 INFO 11644 --- [main] com.example.demo01.Demo01Application: Starting Demo01Application on 20180528-132245 with PID 11644 (D:\\SpringBoot\\project\\demo01\\target\\classes started by Administrator in D:\\SpringBoot\\project\\demo01) 2019-01-09 21:10:41.821 INFO 11644 --- [main] com.example.demo01.Demo01Application: No active profile set, falling back to default profiles: default 2019-01-09 21:10:43.160 INFO 11644 --- [main] com.example.demo01.Demo01Application: Started Demo01Application in 1.955 seconds (JVM running for 3.395) Process finished with exit code 0 原因：创建的pom.xml有问题， &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-tomcat&lt;/artifactId> &lt;scope>provided&lt;/scope> &lt;/dependency> pom文件中有这个依赖，这个是什么意思呢？ 简单来说就是：我把外部的一个tomcat引入了。 这下你明白了吧，spring boot内部本来就有一个。你现在又引入了一个，这下出问 解决方案：上述代码删掉，重新Import changes就Ok了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jiubanmoli.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jiubanmoli.github.io/tags/SpringBoot/"}]},{"title":"阿里云服务器无法访问配置的服务端口","slug":"systemBuild-two","date":"2019-11-16T07:02:18.058Z","updated":"2022-01-04T13:58:00.152Z","comments":true,"path":"2019/11/16/systembuild-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/11/16/systembuild-two/","excerpt":"","text":"原因分析：阿里云为了安全考虑，需要设置安全规则，否则会导致无法访问到服务器的相关端口。 解决方法：在云服务器管理控制台按以下步骤简单设置一下即可 点击添加规则，设置端口 注意： 添加完安全规则后需要重启服务器才能生效。 然后windows+R，输入mstsc打开远程桌面输入公网IP和凭据即可，一般用户名 默认为administrator。 作者：csdn2497242041 链接：https://blog.csdn.net/CSDN2497242041/article/details/78776600 來源：CSDN document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"服务器","slug":"服务器","permalink":"http://jiubanmoli.github.io/categories/服务器/"}],"tags":[{"name":"服务器环境搭建","slug":"服务器环境搭建","permalink":"http://jiubanmoli.github.io/tags/服务器环境搭建/"}]},{"title":"阿里云学生服务器的购买和配置方法","slug":"systemBuild","date":"2019-11-15T12:47:27.123Z","updated":"2022-01-04T13:58:00.159Z","comments":true,"path":"2019/11/15/systembuild/","link":"","permalink":"http://jiubanmoli.github.io/2019/11/15/systembuild/","excerpt":"","text":"一、购买1.登录阿里云官网 https://www.aliyun.com/ 2.滚动你手中的鼠标，滑至网站首页的末端。 3.如下图所示： 4.按照上面提供的学生认证流程，完成学生认证，认证成功就会出现【恭喜您，已完成学生认证，解锁全部时长】 5.选择好你所有购买的服务(笔者选择【轻量应用服务器】)–&gt;【预装环境(系统镜像–&gt;Windows Server 2012 R2 64位)】–&gt;【地域】–&gt;【购买时长】，点击【立即购买】 6.会让你付款，付款成功后，回到阿里云首页，点击导航栏【控制台】 7.在控制台一次点击【产品与服务】–&gt;【轻量应用服务器】，如下图所示 8.跳转到【轻量应用服务器】后，可以看到你购买的服务器的详细信息，如下图所示 9.点击你的服务器，跳转到服务器详细信息页面，做两件事情 记住你的服务器的公网ip。 重置密码，这个密码是远程连接服务器的密码，按要求设置好之后，重启你的服务器 至此，你的阿里云服务器就已经购买完成。下面将讨论如何使用这个服务器。 二、远程登录远程连接有以下两种方式 使用浏览器发起安全连接 通过远程桌面工具连接（如Windows自带的远程桌面连接工具） 具体连接方法可以参考《Windows远程桌面工具配置说明》 连接的时候，笔者并不是一次就连接成功，这里贴上可能出现的错误的解决方案，希望有用 可能出现问题的解决方案https://www.cnblogs.com/raswin/p/9018388.html 三、环境配置和项目部署1.环境配置 前期准备： 将你的web项目打包成war(确保你个项目能在你的本机正常运行，访问)、由于我们需要在远程主机上从我们本地拷贝相关文件，因此需将本地某个盘共享到远程服务器中，故需要将自己项目运行的环境放在本机的一个磁盘上(如，笔者在F盘根目录下新建【我的远程项目】文件夹，在该文件夹下存放，MySQL数据库，JDK，Tomcat，数据库文件等)。 远程连接：详情请看下图 (1).Window+R -&gt; 输入mstsc 回车 来到这个界面 (2).如上图输入我们购买的云服务器的外网ip (3).确定后点击连接 用户名为Administrator，密码为之前设置的那个很复杂的那个密码(即之前点击重置密码时设置的密码) ，点击确定进入远程主机界面。成功后，会看到如下图所示界面。 2.项目部署 运行环境： 需要注意的是！！！必须配置JAVA_HOME和CATALINA_HOME否则tomcat启动会失败(必须配置这两个HOME) 环境配置如下: 1.1配置JAVA_HOME 在环境变量中新建环境变量，名为JAVA_HOME，内容为Java安装根目录,例如C:\\Java\\jdk_1.7.0_13.在环境变量中找到path环境变量，在最后面加上 ;%JAVA_HOME%\\bin; (注意前后的两个分号不可少) 。 验证:Windows+R 输入cmd 键入javac 验证是否成功。 1.2配置CATALINA_HOME 在环境变量中新建环境变量,名为CATALINA_HOME,内容为tomcat根目录,例如：C:\\apache-tomcat-7.0.56 在环境变量中找到path环境变量,在最后面加上 ;%CATALINA_HOME\\bin; (注意前后的两个分号不可少) 。 验证：进入tomcat目录下的bin目录下运行startup.bat文件,若能正常启动服务，则说明配置成功，若启动服务一闪而过，表示失败 失败原因有两种：1.JAVA_HOME路径有误 2.CATALINA_HOME路径有误 自己检查。 以上已完成正常的服务配置，启动服务后，打开远程主机上的浏览器，输入http://localhost:8080 若能访问到tomcat主页，则说明配置成功。 部署项目： 接下来将外网ip配置进去，即可通过外网ip访问我们的远程服务器，具体操作如下: 进入tomcat根目录，找到conf下的server.xml文件，找到host根节点。 将原来的name=\"localhost\" 中的localhost改成我们的外网ip.保存后，重启服务 验证:随便使用一台电脑打开浏览器，输入【公网ip:8080】即可访问到我们远程主机上的web项目。 不加端口号访问项目的方法 将Connector节点下的port属性值改成80即可在访问的时候不加端口号.http默认端口号为80因此我们可以不用输入端口号。 作者：翎幺 链接：https://ahualy.github.io/post/a-li-yun/ 來源：Github document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"服务器","slug":"服务器","permalink":"http://jiubanmoli.github.io/categories/服务器/"}],"tags":[{"name":"服务器环境搭建","slug":"服务器环境搭建","permalink":"http://jiubanmoli.github.io/tags/服务器环境搭建/"}]},{"title":"Connection is read-only. Queries leading to data modification are not allowed 的产生原因及解决方案","slug":"ssm-three","date":"2019-01-20T11:28:33.608Z","updated":"2022-01-04T13:58:00.148Z","comments":true,"path":"2019/01/20/ssm-three/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/ssm-three/","excerpt":"","text":"spring.xml:文件 &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"> &lt;tx:attributes> &lt;tx:method name=\"save*\" propagation=\"REQUIRED\" read-only=\"false\" /> &lt;tx:method name=\"add*\" propagation=\"REQUIRED\" read-only=\"false\" /> &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\" read-only=\"false\" /> &lt;tx:method name=\"update*\" propagation=\"REQUIRED\" read-only=\"false\" /> &lt;tx:method name=\"list*\" propagation=\"REQUIRED\" read-only=\"true\" /> &lt;tx:method name=\"get*\" propagation=\"REQUIRED\" /> &lt;tx:method name=\"import*\" propagation=\"REQUIRED\" read-only=\"false\" /> &lt;tx:method name=\"export*\" propagation=\"REQUIRED\" read-only=\"true\" /> &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"true\" /> &lt;/tx:attributes> &lt;/tx:advice> 分析：service层里面有参与事物的方法没有按以上规则来命名，而以上配置文件规定了数据库操作函数必须要以上面的字符串开头，否则的话就按照默认的配置，对数据库访问的权限为read-only。 报错原因：我的因为service层中的方法名违背了以上规则，只要将方法名改下就可以了 解决办法：1.修改service里面方法的名字，改为符合配置文件的规则。2.当然也可以把read-only=”true”去掉，(不推荐这种做法) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SSM","slug":"SSM","permalink":"http://jiubanmoli.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://jiubanmoli.github.io/tags/SSM/"}]},{"title":"关于表单自动提交的问题及解决方式","slug":"form","date":"2019-01-20T11:24:18.114Z","updated":"2022-01-04T13:58:00.063Z","comments":true,"path":"2019/01/20/form/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/form/","excerpt":"","text":"在js中，我们常常会用到表单提交，但小编今天遇到一个问题：在删除所有引用的js文件之后，页面还是刷新 最后发现问题如下： 在js中，使用表单提交，即使你不写$(“XXX”).submit()也会使得表单提交，那如何寻找这种问题解决方式呢？ 总结问题及解决方式如下: (1)使用onsubmit()阻止表单提交，但是会有一个触发问题，onsubmit 事件只有在表单中的确认按钮被点击时发生触发。原因如下： 先看一段代码： &lt;form action=\"index.jsp\" method=\"post\" onsubmit=\"submitTest();\"> &lt;INPUT value=\"www\"> &lt;input type=\"submit\" value=\"submit\"> &lt;/form> &lt;SCRIPT LANGUAGE=\"JavaScript\"> &lt;!-- function submitTest() { // 一些逻辑判断return false; } //-->&lt;/SCRIPT> 在点击该submit按钮时并没有发生触发事件，原因为何？应该在onsubmit中加上return submitTest()；onsubmit属性就像是这个html对象的一个方法名，其值（一字符串）就是其方法体，默认返回true； submitTest()虽然返回false，但我们只执行了此函数，没有对其结果进行任何处理,而onsubmit=”return submitTest()利用到了它的返回值，达到了预期效果。 (2)使用return false来阻止表单的默认行为 &lt;form name=\"loginForm\" action=\"login.aspx\" method=\"post\"> &lt;button type=\"submit\" value=\"Submit\" id=\"submit\">Submit&lt;/button> &lt;/form> &lt;script> var submitBtn = document.getElementById(\"submit\"); submitBtn.onclick = function (event) { alert(\"preventDefault!\"); return false; }; &lt;/script> 最后：事件处理函数返回false的问题，在大多数情况下,为事件处理函数返回false,可以防止默认的事件行为. (3)使用preventDefault()来阻止浏览器默认提交表单行为 在标准浏览器中，阻止浏览器默认行为使用event.preventDefault()，而在IE6~8中，使用returnValue属性来实现。 请看如下代码 &lt;form name=\"loginForm\" action=\"login.aspx\" method=\"post\"> &lt;button type=\"submit\" value=\"Submit\" id=\"submit\">Submit&lt;/button> &lt;/form> &lt;script> var submitBtn = document.getElementById(\"submit\"); submitBtn.onclick = function (event) { alert(\"preventDefault!\"); var event = event || window.event; event.preventDefault(); // 兼容标准浏览器 window.event.returnValue = false; // 兼容IE6~8 }; &lt;/script> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"HTML","slug":"HTML","permalink":"http://jiubanmoli.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://jiubanmoli.github.io/tags/HTML/"},{"name":"Jquery","slug":"Jquery","permalink":"http://jiubanmoli.github.io/tags/Jquery/"}]},{"title":"Package should contain a content type part [M1.13]异常的解决方式","slug":"HSSFWORK","date":"2019-01-20T11:21:46.578Z","updated":"2022-01-04T13:57:59.997Z","comments":true,"path":"2019/01/20/hssfwork/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/hssfwork/","excerpt":"","text":"此异常的源代码如下： public static Workbook create(InputStream in) throws IOException,InvalidFormatException { if (!in.markSupported()) { in = new PushbackInputStream(in, 8); } if (POIFSFileSystem.hasPOIFSHeader(in)) { return new HSSFWorkbook(in); } if (POIXMLDocument.hasOOXMLHeader(in)) { return new XSSFWorkbook(OPCPackage.open(in)); } throw new IllegalArgumentException(\"你的excel版本目前poi解析不了\"); } 解决方式： 读写xls和xlsx格式时，HSSFWorkbook针对xls，XSSFWorkbook针对xlsx 主要是格式的问题！ 作者主要是将xls文件格式改成了xlsx就没有问题了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/tags/Java-Web/"}]},{"title":"form表单中关于ajaxForm与ajaxSubmit的两种提交方式的用法和区别","slug":"ajax-three","date":"2019-01-20T11:19:57.480Z","updated":"2022-01-04T13:58:00.051Z","comments":true,"path":"2019/01/20/ajax-three/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/ajax-three/","excerpt":"","text":"(1)用法:ajaxForm和ajaxSubmit都可以接收0或1个参数，该参数可以是一个变量，一个对象或回调函数，这个对象主要有一下参数 : var object = { url : url,//form提交数据的路径 type : type,//form提交的方式(method:get/post) target : target,//服务器返回响应数据显示的元素(Id)号 beforeSerialize : function(){},//序列化提交数据之前的回调函数 beforeSubmit : function(){},//提交之前执行的回调函数 success : function(){},//提交成功之后返回的回调函数 error : function(){},//提交失败后返回的回调函数 dataType : null,//服务器返回的数据类型 clearForm : true,//提交成功后是否清空表单中的字段值 restForm : true,//提交成功后是否重置表单中的字段值，即恢复到页面加载时的状态 timeout : 6000,//设置请求时间，超过请求时间后，自动退出请求 } (2)区别:ajaxForm不能主动提交form表单，函数只是为提交表单做准备需要以submit来触发提交，而ajaxSubmit会自动提交表单，同时也可以在点击其他按钮也可以触发提交，不一定是submit按钮。ajaxForm执行的时候其实相当于： $(\"form\").submit(function(){ $(this).ajaxSubmit(); return false;//此句解释了为什么ajaxSubmit会自动提交表单，想要阻止自动提交，必须return false; }) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"HTML","slug":"HTML","permalink":"http://jiubanmoli.github.io/categories/HTML/"}],"tags":[{"name":"html","slug":"html","permalink":"http://jiubanmoli.github.io/tags/html/"},{"name":"jquery","slug":"jquery","permalink":"http://jiubanmoli.github.io/tags/jquery/"}]},{"title":"关于$.ajax()中使用serialize()提交form表单数据","slug":"ajax-two","date":"2019-01-20T11:18:01.029Z","updated":"2022-01-04T13:58:00.043Z","comments":true,"path":"2019/01/20/ajax-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/ajax-two/","excerpt":"","text":"提交多个数据时，不需要一个一个将获取的值传给ajax,可以直接使用$(“form”).serialize()将其表单序列化的值传给ajax()作为url的参数，轻松使用ajax提交form表单了。例: $.ajax({ type:'post', url : url, data : $(\"form\").serialize(), success : function(data){ } }) 关于序列化表单之后出现的中文乱码问题原因及解决方案:(1)原因:使用ajax请求之后，当没有设定请求的type时，默认采用的是get请求方式，而get请求方式要采用(String)request.getParameter(“username”),”utf-8”);对每个中文进行单独的转码才能解决乱码问题(2)解决方案:使用post请求方式进行提交表单 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"HTML","slug":"HTML","permalink":"http://jiubanmoli.github.io/categories/HTML/"}],"tags":[{"name":"html","slug":"html","permalink":"http://jiubanmoli.github.io/tags/html/"},{"name":"jquery","slug":"jquery","permalink":"http://jiubanmoli.github.io/tags/jquery/"}]},{"title":"Java中的JsonConfig详解","slug":"JSONConfig","date":"2019-01-20T11:15:14.894Z","updated":"2022-01-04T13:58:00.002Z","comments":true,"path":"2019/01/20/jsonconfig/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/jsonconfig/","excerpt":"","text":"JSON lib能够将Java对象转成json格式的字符串，也可以将Java对象转换成xml格式的文档，同样可以将json字符串转换成Java对象或是将xml字符串转换成Java对象。无论出于何种原因，某些时候，我们需要对对象转为字符串的过程加以控制，最常见需求如数值格式化和日期格式化。JSON lib提供了JsonConfig对象，该对象能够深刻影响Java对象转成json字符串的行为。比如我们要控制JSON序列化过程中的Date对象的格式化，以及数值的格式化，JsonValueProcessor是最好的选择。 (1)JsonValueProcessorExample：java里面时间类型转换成json数据就成这样了： “createTime”:{“date”:30,”day”:3,”hours”:15,”minutes”:14,”month”:3,”nanos”:0,”seconds”:38,”time”:1209539678000,”timezoneOffset”:-480,”year”:108} 期望的结果是”yyyy-mm–dd” 解决方案:使用jsonConfig即可 JsonConfig jsonConfig = new JsonConfig(); jsonConfig.registerJsonValueProcessor(java.util.Date.class, new DateJsonValueProcessor(\"yyyy-MM-dd HH:mm:ss\")); (2)setIgnoreDefaultExcludesExample: @SuppressWarnings(\"unchecked\") public static void testMap() { Map map = new HashMap(); map.put(\"name\", \"json\"); map.put(\"class\", \"ddd\"); JsonConfig config = new JsonConfig(); config.setIgnoreDefaultExcludes(true); //默认为false，即过滤默认的key JSONObject jsonObject = JSONObject.fromObject(map,config); System.out.println(jsonObject); } 上面的代码会把name 和 class都输出 而去掉setIgnoreDefaultExcludes(true)的话，就只会输出name，不会输出class。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://jiubanmoli.github.io/tags/JSON/"}]},{"title":"StringUtils.isEmpty用法","slug":"StringToConvert-two","date":"2019-01-20T11:02:32.337Z","updated":"2022-01-04T13:58:00.027Z","comments":true,"path":"2019/01/20/stringtoconvert-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/stringtoconvert-two/","excerpt":"","text":"StringUtils 方法的操作对象是 Java.lang.String 类型的对象，是 JDK 提供的 String 类型操作方法的补充，并且是 null 安全的(即如果输入参数 String 为 null 则不会抛出 NullPointerException ，而是做了相应处理，例如，如果输入为 null 则返回也是 null 等，具体可以查看源代码)。 除了构造器，StringUtils 中一共有130多个方法，并且都是 static 的，所以我们可以这样调用 StringUtils.xxx() 下面分别对一些常用方法做简要介绍： 1. public static boolean isEmpty(String str) 判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0下面是 StringUtils 判断是否为空的示例： StringUtils.isEmpty(null) = true StringUtils.isEmpty(\"\") = true StringUtils.isEmpty(\" \") = false //注意在 StringUtils 中空格作非空处理 StringUtils.isEmpty(\" \") = false StringUtils.isEmpty(\"bob\") = false StringUtils.isEmpty(\" bob \") = false 2. public static boolean isNotEmpty(String str) 判断某字符串是否非空，等于 !isEmpty(String str)下面是示例： StringUtils.isNotEmpty(null) = false StringUtils.isNotEmpty(\"\") = false StringUtils.isNotEmpty(\" \") = true StringUtils.isNotEmpty(\" \") = true StringUtils.isNotEmpty(\"bob\") = true StringUtils.isNotEmpty(\" bob \") = true 3. public static boolean isBlank(String str) 判断某字符串是否为空或长度为0或由空白符(whitespace) 构成下面是示例： StringUtils.isBlank(null) = true StringUtils.isBlank(\"\") = true StringUtils.isBlank(\" \") = true StringUtils.isBlank(\" \") = true StringUtils.isBlank(\"\\t \\n \\f \\r\") = true //对于制表符、换行符、换页符和回车符 StringUtils.isBlank() //均识为空白符 StringUtils.isBlank(\"\\b\") = false //\"\\b\"为单词边界符 StringUtils.isBlank(\"bob\") = false StringUtils.isBlank(\" bob \") = false 4. public static boolean isNotBlank(String str) 判断某字符串是否不为空且长度不为0且不由空白符(whitespace) 构成，等于 !isBlank(String str)下面是示例： StringUtils.isNotBlank(null) = false StringUtils.isNotBlank(\"\") = false StringUtils.isNotBlank(\" \") = false StringUtils.isNotBlank(\" \") = false StringUtils.isNotBlank(\"\\t \\n \\f \\r\") = false StringUtils.isNotBlank(\"\\b\") = true StringUtils.isNotBlank(\"bob\") = true StringUtils.isNotBlank(\" bob \") = true 5. public static String trim(String str)去掉字符串两端的控制符(control characters, char &lt;= 32) , 如果输入为 null 则返回null下面是示例： StringUtils.trim(null) = null StringUtils.trim(\"\") = \"\" StringUtils.trim(\" \") = \"\" StringUtils.trim(\" \\b \\t \\n \\f \\r \") = \"\" StringUtils.trim(\" \\n\\tss \\b\") = \"ss\" StringUtils.trim(\" d d dd \") = \"d d dd\" StringUtils.trim(\"dd \") = \"dd\" StringUtils.trim(\" dd \") = \"dd\" 6. public static String trimToNull(String str)去掉字符串两端的控制符(control characters, char &lt;= 32) ,如果变为 null 或””，则返回 null下面是示例： StringUtils.trimToNull(null) = null StringUtils.trimToNull(\"\") = null StringUtils.trimToNull(\" \") = null StringUtils.trimToNull(\" \\b \\t \\n \\f \\r \") = null StringUtils.trimToNull(\" \\n\\tss \\b\") = \"ss\" StringUtils.trimToNull(\" d d dd \") = \"d d dd\" StringUtils.trimToNull(\"dd \") = \"dd\" StringUtils.trimToNull(\" dd \") = \"dd\" 7. public static String trimToEmpty(String str)去掉字符串两端的控制符(control characters, char &lt;= 32) ,如果变为 null 或 “” ，则返回 “”下面是示例： StringUtils.trimToEmpty(null) = \"\" StringUtils.trimToEmpty(\"\") = \"\" StringUtils.trimToEmpty(\" \") = \"\" StringUtils.trimToEmpty(\" \\b \\t \\n \\f \\r \") = \"\" StringUtils.trimToEmpty(\" \\n\\tss \\b\") = \"ss\" StringUtils.trimToEmpty(\" d d dd \") = \"d d dd\" StringUtils.trimToEmpty(\"dd \") = \"dd\" StringUtils.trimToEmpty(\" dd \") = \"dd\" 8. public static String strip(String str)去掉字符串两端的空白符(whitespace) ，如果输入为 null 则返回 null下面是示例(注意和 trim() 的区别)： StringUtils.strip(null) = null StringUtils.strip(\"\") = \"\" StringUtils.strip(\" \") = \"\" StringUtils.strip(\" \\b \\t \\n \\f \\r \") = \"\\b\" StringUtils.strip(\" \\n\\tss \\b\") = \"ss \\b\" StringUtils.strip(\" d d dd \") = \"d d dd\" StringUtils.strip(\"dd \") = \"dd\" StringUtils.strip(\" dd \") = \"dd\" 9. public static String stripToNull(String str)去掉字符串两端的空白符(whitespace) ，如果变为 null 或””，则返回 null下面是示例(注意和 trimToNull() 的区别)： StringUtils.stripToNull(null) = null StringUtils.stripToNull(\"\") = null StringUtils.stripToNull(\" \") = null StringUtils.stripToNull(\" \\b \\t \\n \\f \\r \") = \"\\b\" StringUtils.stripToNull(\" \\n\\tss \\b\") = \"ss \\b\" StringUtils.stripToNull(\" d d dd \") = \"d d dd\" StringUtils.stripToNull(\"dd \") = \"dd\" StringUtils.stripToNull(\" dd \") = \"dd\" 10. public static String stripToEmpty(String str)去掉字符串两端的空白符(whitespace) ，如果变为 null 或”” ，则返回””下面是示例(注意和 trimToEmpty() 的区别)： StringUtils.stripToNull(null) = \"\" StringUtils.stripToNull(\"\") = \"\" StringUtils.stripToNull(\" \") = \"\" StringUtils.stripToNull(\" \\b \\t \\n \\f \\r \") = \"\\b\" StringUtils.stripToNull(\" \\n\\tss \\b\") = \"ss \\b\" StringUtils.stripToNull(\" d d dd \") = \"d d dd\" StringUtils.stripToNull(\"dd \") = \"dd\" StringUtils.stripToNull(\" dd \") = \"dd\" 以下方法只介绍其功能，不再举例：11. public static String strip(String str, String stripChars) 去掉 str 两端的在 stripChars 中的字符。 如果 str 为 null 或等于”” ，则返回它本身； 如果 stripChars 为 null 或”” ，则返回 strip(String str) 。 12. public static String stripStart(String str, String stripChars) 和11相似，去掉 str 前端的在 stripChars 中的字符。 13. public static String stripEnd(String str, String stripChars) 和11相似，去掉 str 末端的在 stripChars 中的字符。 14. public static String[] stripAll(String[] strs) 对字符串数组中的每个字符串进行 strip(String str) ，然后返回。 如果 strs 为 null 或 strs 长度为0，则返回 strs 本身 15. public static String[] stripAll(String[] strs, String stripChars) 对字符串数组中的每个字符串进行 strip(String str, String stripChars) ，然后返回。 如果 strs 为 null 或 strs 长度为0，则返回 strs 本身 16. public static boolean equals(String str1, String str2) 比较两个字符串是否相等，如果两个均为空则也认为相等。 17. public static boolean equalsIgnoreCase(String str1, String str2) 比较两个字符串是否相等，不区分大小写，如果两个均为空则也认为相等。 18. public static int indexOf(String str, char searchChar) 返回字符 searchChar 在字符串 str 中第一次出现的位置。 如果 searchChar 没有在 str 中出现则返回-1， 如果 str 为 null 或 “” ，则也返回-1 19. public static int indexOf(String str, char searchChar, int startPos) 返回字符 searchChar 从 startPos 开始在字符串 str 中第一次出现的位置。 如果从 startPos 开始 searchChar 没有在 str 中出现则返回-1， 如果 str 为 null 或 “” ，则也返回-1 20. public static int indexOf(String str, String searchStr) 返回字符串 searchStr 在字符串 str 中第一次出现的位置。 如果 str 为 null 或 searchStr 为 null 则返回-1， 如果 searchStr 为 “” ,且 str 为不为 null ，则返回0， 如果 searchStr 不在 str 中，则返回-1 21. public static int ordinalIndexOf(String str, String searchStr, int ordinal) 返回字符串 searchStr 在字符串 str 中第 ordinal 次出现的位置。 如果 str=null 或 searchStr=null 或 ordinal&lt;=0 则返回-1 举例(*代表任意字符串)： StringUtils.ordinalIndexOf(null, *, *) = -1 StringUtils.ordinalIndexOf(*, null, *) = -1 StringUtils.ordinalIndexOf(\"\", \"\", *) = 0 StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1) = 0 StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2) = 1 StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1) = 2 StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2) = 5 StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1) = 1 StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2) = 4 StringUtils.ordinalIndexOf(\"aabaabaa\", \"bc\", 1) = -1 StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1) = 0 StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2) = 0 22. public static int indexOf(String str, String searchStr, int startPos) 返回字符串 searchStr 从 startPos 开始在字符串 str 中第一次出现的位置。 举例(*代表任意字符串)： StringUtils.indexOf(null, *, *) = -1 StringUtils.indexOf(*, null, *) = -1 StringUtils.indexOf(\"\", \"\", 0) = 0 StringUtils.indexOf(\"aabaabaa\", \"a\", 0) = 0 StringUtils.indexOf(\"aabaabaa\", \"b\", 0) = 2 StringUtils.indexOf(\"aabaabaa\", \"ab\", 0) = 1 StringUtils.indexOf(\"aabaabaa\", \"b\", 3) = 5 StringUtils.indexOf(\"aabaabaa\", \"b\", 9) = -1 StringUtils.indexOf(\"aabaabaa\", \"b\", -1) = 2 StringUtils.indexOf(\"aabaabaa\", \"\", 2) = 2 StringUtils.indexOf(\"abc\", \"\", 9) = 3 23. public static int lastIndexOf(String str, char searchChar) 基本原理同18 24. public static int lastIndexOf(String str, char searchChar, int startPos) 基本原理同19 25. public static int lastIndexOf(String str, String searchStr) 基本原理同20 26. public static int lastIndexOf(String str, String searchStr, int startPos) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"String字符串","slug":"String字符串","permalink":"http://jiubanmoli.github.io/tags/String字符串/"}]},{"title":"e.stopPropagation与e.cancelBubble的区别","slug":"jquery","date":"2019-01-20T10:45:39.302Z","updated":"2022-01-04T13:58:00.083Z","comments":true,"path":"2019/01/20/jquery/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/jquery/","excerpt":"","text":"相同之处：都是阻止服务器的默认行为不同之处：stopPropagation符合w3c标准，是应用于firefox浏览器，而不支持IE浏览器，而cancelBubble则相反，不符合w3c标准，只支持ＩＥ浏览器。cancelBubble:设置或获取当前事件是否要在事件句柄中向上冒泡 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"HTML","slug":"HTML","permalink":"http://jiubanmoli.github.io/categories/HTML/"}],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://jiubanmoli.github.io/tags/Jquery/"}]},{"title":"JSONObject与JSONArray()的使用","slug":"JSONConvert","date":"2019-01-20T10:38:27.171Z","updated":"2022-01-04T13:57:59.994Z","comments":true,"path":"2019/01/20/jsonconvert/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/jsonconvert/","excerpt":"","text":"1.从Object到String要先用Object构造一个JSONObject对象或者一个JSONArray对象，然后调用他的toString()方法即可。–&gt;1.案例一: Book book=new Book(); book.setName(\"Java\"); book.setPrice(52.3f); JSONObject object=JSONObject.fromObject(book); System.out.println(object.toString()); –&gt;2.案例二: Book book=new Book(); book.setName(\"Java\"); book.setPrice(52.3f); Book book2=new Book(); book2.setName(\"C\"); book2.setPrice(42.3f); List list=new ArrayList(); list.add(book); ist.add(book2); JSONArray arry=JSONArray.fromObject(list); System.out.println(arry.toString()); //结果如下： [{\"name\":\"Java\",\"price\":52.3},{\"name\":\"C\",\"price\":42.3}] 2.从String到Object要先用String对象构造一个JSONObject或者JSONArray对象——&gt;1.案例一： String json=\"{name:'Java',price:52.3}\"; JSONObject object=JSONObject.fromObject(json); System.out.println(object.get(\"name\")+\" \"+object.get(\"price\")); ——–&gt;2.案例二: String json=\"[{name:'Java',price:52.3},{name:'C',price:42.3}]\"; JSONArray array=JSONArray.fromObject(json); for(int i=0;i&lt;array.size();i++){ Map o=(Map)array.get(i); System.out.println(o.get(\"name\")+\" \"+o.get(\"price\")); } 3.从String到Bean——-&gt;1.单个Bean对象 String json=\"{name:'Java',price:52.3}\"; JSONObject object=JSONObject.fromObject(json); Product product=(Product)JSONObject.toBean(object,Product.class); System.out.println(product.getName()+\" \"+product.getPrice()); ——–&gt;2.Bean的数组 String json=\"[{name:'Java',price:52.3},{name:'C',price:42.3}]\"; JSONArray array=JSONArray.fromObject(json); Product[] products=(Product[]) JSONArray.toArray(array,Product.class); for(Product p:products){ System.out.println(p.getName()+\" \"+p.getPrice()); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"JSONObject","slug":"JSONObject","permalink":"http://jiubanmoli.github.io/tags/JSONObject/"},{"name":"JSONArray","slug":"JSONArray","permalink":"http://jiubanmoli.github.io/tags/JSONArray/"}]},{"title":"简要概述对spring security与shrio的认识与区别","slug":"SpringSecurity-two","date":"2019-01-20T10:34:21.449Z","updated":"2022-01-04T13:58:00.035Z","comments":true,"path":"2019/01/20/springsecurity-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/springsecurity-two/","excerpt":"","text":"最近看到项目中使用到了shrio和spring security,这两者都是对权限的控制与管理，为了了解两者的区别，查阅了相关资料，进行了一个整理: Apache shrio是Java的一个安全框架，但是shrio框架的一大特点强大而灵活并且简单，容易使用，相比spring security框架没有那么晦涩难懂，它能清晰的处理认证，授权，管理会话以及密码加密。但是相比于spring security，可能没有spring security做的相关功能强大，所以具体使用哪个框架主要看你本身的项目是都需要那些复杂功能一些相关的东西。但因为我项目中运用到了spring security，所以后面的博文可能会对spring security做一下详细的了解以及介绍总结。 以下是shrio所具有的一些特点: 1.易于理解的 Java Security API； 2.简单的身份认证（登录），支持多种数据源（LDAP，JDBC，Kerberos，ActiveDirectory 等）； 3.对角色的简单的签权（访问控制），支持细粒度的签权； 4.支持一级缓存，以提升应用程序的性能； 5.内置的基于 POJO 企业会话管理，适用于 Web 以及非 Web 的环境； 6异构客户端会话访问； 7.非常简单的加密 API； 8.不跟任何的框架或者容器捆绑，可以独立运行 spring security:spring security对于spring的结合较好，如果项目用的是springmvc使用起来挺方便，如果项目没有使用spring，先暂时不考虑了，shrio因为是Apache下的一个项目，不跟任何容器和框架绑定，可以独立运行，所以相对来说简便灵活。但对于shiro所具有的一系列功能，spring security都有，包括认证，验证，授权等等，目前spring security较好的解决了功能级权限管理的问题，并且spring security对Oauth、OpenID也有支持,Shiro则需要自己手动实现，作者自己还整理了一些资料，说spring security的权限细粒度更高，当然，关于这里，作者还没有深入去了解，这里主要是对shrio和spring security做一个大概总结，并且对spring security有一个大概的认识。 转载: 以下是对Oauth以及OpenId的一些认知: Oauth:在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。 “客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。 OpenId: 系统的第一部分是身份验证，即如何通过 URI 来认证用户身份。目前的网站都是依靠用户名和密码来登录认证，这就意味着大家在每个网站都需要注册用户名和密码，即便你使用的是同样的密码。如果使用 OpenID ，你的网站地址（URI）就是你的用户名，而你的密码安全的存储在一个 OpenID 服务网站上（你可以自己建立一个 OpenID 服务网站，也可以选择一个可信任的 OpenID 服务网站来完成注册）。 与OpenID同属性的身份识别服务商还有ⅥeID,ClaimID,CardSpace,Rapleaf,Trufina ID Card等，其中ⅥeID通用账户的应用最为广泛。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://jiubanmoli.github.io/categories/Spring-Security/"}],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://jiubanmoli.github.io/tags/Spring-Security/"},{"name":"Shiro","slug":"Shiro","permalink":"http://jiubanmoli.github.io/tags/Shiro/"}]},{"title":"关于spring security的简要介绍以及相关配置和jar包认识","slug":"SpringSecurity","date":"2019-01-20T10:26:25.347Z","updated":"2022-01-04T13:58:00.007Z","comments":true,"path":"2019/01/20/springsecurity/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/springsecurity/","excerpt":"","text":"介绍Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。 安全主要包括两个操作，”认证和验证(权限控制)”，现在是spring security面向的两个主要方向，“认证” 是为用户建立一个他所声明的主体的过程， （“主体”一般是指用户，设备或可以在你系统中执行行动的其他系统）。 “验证”指的一个用户能否在你的应用中执行某个操作。 在身份验证层面，Spring Security广泛支持各种身份验证模式。 这些验证模型绝大多数都由第三方提供，或正在开发的有关标准机构提供的，例如Internet Engineering Task Force。 作为补充，Spring Security也提供了自己的一套验证功能。 Spring Security目前支持认证一体化和如下认证技术： HTTP BASIC authentication headers (一个基于IETF RFC的标准) HTTP Digest authentication headers (一个基于IETF RFC的标准) HTTP X.509 client certificate exchange (一个基于IETF RFC的标准) LDAP (一个非常常见的跨平台认证需要做法，特别是在大环境) Form-based authentication (提供简单用户接口的需求) OpenID authentication 基于预先建立的请求头进行认证 （比如Computer Associates Siteminder） JA-SIG Central Authentication Service (也被称为CAS，这是一个流行的开源单点登录系统) Transparent authentication context propagation for Remote Method Invocation (RMI) and HttpInvoker (一个Spring远程调用协议) Automatic “remember-me” authentication (这样你可以设置一段时间，避免在一段时间内还需要重新验证) Anonymous authentication (允许未认证的任何调用，自动假设一个特定的安全主体) Run-as authentication (这在一个会话内使用不同安全身份的时候是非常有用的) Java Authentication and Authorization Service (JAAS) JEE Container autentication (这样，你可以继续使用容器管理认证，如果想的话) Kerberos Java Open Source Single Sign On (JOSSO) * OpenNMS Network Management Platform * AppFuse * AndroMDA * Mule ESB * Direct Web Request (DWR) * Grails * Tapestry * JTrac * Jasypt * Roller * Elastic Plath * Atlassian Crowd * 你自己的认证系统(向下看) 许多独立软件供应商（ISVs, independent software vendors）采用Spring Security，是因为它拥有丰富灵活的验证模型。 这样，无论终端用户需要什么，他们都可以快速集成到系统中，不用花很多功夫，也不用让用户改变运行环境。 如果上述的验证机制都没有满足你的需要，Spring Security是一个开放的平台，编写自己的验证机制是十分简单的。 Spring Security的许多企业用户需要整合不遵循任何特定安全标准的“遗留”系统，Spring Security在这类系统上也表现的很好。 Spring Security不仅提供认证功能，也提供了完备的授权功能。 在授权方面主要有三个领域，授权web请求，授权被调用方法，授权访问单个对象的实例。 为了帮你了解它们之间的区别，对照考虑授在Servlet规范web模式安全，EJB容器管理安全，和文件系统安全方面的授权方式。 Spring Security在所有这些重要领域都提供了完备的能力 好了，简述到这里下面主要介绍一下spring security相关的一些jar包： 1.4.1.1. Core - spring-security-core.jar 包含了核心认证和权限控制类和接口， 运程支持和基本供应API。使用Spring Security所必须的。支持单独运行的应用， 远程客户端，方法（服务层）安全和JDBC用户供应。包含顶级包： org.springframework.security.core org.springframework.security.access org.springframework.security.authentication org.springframework.security.provisioning 1.4.1.2. 远程调用 - spring-security-remoting.jar 提供与Spring远程调用的集成。你不需要它，除非你写了一个远程客户端 使用Spring Remoting。 主包是 org.springframework.security.remoting。 1.4.1.3. Web - spring-security-web.jar 包含过滤器和对应的web安全架构代码。任何需要依赖servlet API的。 你将需要它，如果你需要Spring Security Web认证服务和基于URL的权限控制。 主包是org.springframework.security.web。 1.4.1.4. Config - spring-security-config.jar 包含安全命名控制解析代码，你需要它， 如果使用了Spring Security XML命名控制来进行配置。主包是 org.springframework.security.config。这些类都不应该在应用中直接使用。 1.4.1.5. LDAP - spring-security-ldap.jar LDAP认证和实现代码，如果你需要使用LDAP认证或管理LDAP用户实体就是必须的。 顶级包是org.springframework.security.ldap。 1.4.1.6. ACL - spring-security-acl.jar 处理领域对象ACL实现。用来提供安全给特定的领域对象实例，在你的应用中。 顶级包是org.springframework.security.acls。 1.4.1.7. CAS - spring-security-cas.jar Spring Security的CAs客户端集成。如果你希望使用Spring Security web认证 整合一个CAS单点登录服务器。顶级包是 org.springframework.security.cas。 1.4.1.8. OpenID - spring-security-openid.jar OpenID web认证支持。用来认证用户，通过一个外部的OpenID服务。 org.springframework.security.openid。需要OpenID4Java 配置在pom.xml中的配置如下请看: &lt;dependency> &lt;groupId>org.springframework.security&lt;/groupId> &lt;artifactId>spring-security-web&lt;/artifactId> &lt;version>4.1.2.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.security&lt;/groupId> &lt;artifactId>spring-security-config&lt;/artifactId> &lt;version>4.1.2.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.security&lt;/groupId> &lt;artifactId>spring-security-taglibs&lt;/artifactId> &lt;version>4.1.2.RELEASE&lt;/version> &lt;/dependency> spring security在web.xml中的配置: &lt;!-- Spring Secutiry4.1的过滤器链配置 --> &lt;filter> &lt;filter-name>springSecurityFilterChain&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>springSecurityFilterChain&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> spring security.xml配置如下: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\" xmlns:beans=\"http://www.springframework.org/schema/beans\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd\"> &lt;http pattern=\"/**/js/**/*\" security=\"none\">&lt;/http> &lt;http pattern=\"/**/css/**/*\" security=\"none\">&lt;/http> &lt;http pattern=\"/**/img/**/*\" security=\"none\">&lt;/http> &lt;http pattern=\"/plugins/**/*\" security=\"none\">&lt;/http> &lt;http pattern=\"/bootstrap/**/*\" security=\"none\">&lt;/http> &lt;http pattern=\"/images/**/*\" security=\"none\">&lt;/http> &lt;http pattern=\"/upload/**/*.*\" security=\"none\">&lt;/http> &lt;http auto-config=\"false\" use-expressions=\"true\" entry-point-ref=\"myAuthenticationEntryPoint\" > &lt;!--配置自定义的过滤器--> &lt;custom-filter before=\"FILTER_SECURITY_INTERCEPTOR\" ref=\"securityInterceptor\"/> &lt;!-- 退出处理 --> &lt;logout logout-url=\"/j_spring_security_logout\" logout-success-url=\"/loginlog/logout.do\" invalidate-session=\"true\" /> &lt;custom-filter ref=\"loginFilter\" position=\"FORM_LOGIN_FILTER\" /> &lt;!-- 登录成功后拒绝访问跳转的页面 --> &lt;access-denied-handler ref=\"accessDeniedHandler\" /> &lt;csrf disabled=\"true\" /> &lt;/http> &lt;!-- 自定义权限不足处理程序 --> &lt;beans:bean id=\"accessDeniedHandler\" class=\"com.seawin.webapp.base.security.MyAccessDeniedHandler\"> &lt;beans:property name=\"errorPage\" value=\"/sysadmin/error.jsp?errorCode=1\">&lt;/beans:property> &lt;/beans:bean> &lt;!-- 使用自定义类myUserDetailsService从数据库获取用户信息 --> &lt;authentication-manager alias=\"myAuthenticationManager\"> &lt;authentication-provider user-service-ref=\"myUserDetailsService\">&lt;/authentication-provider> &lt;/authentication-manager> &lt;!-- 自定义用户资源信息获取 --> &lt;beans:bean id=\"myUserDetailsService\" class=\"com.seawin.webapp.base.security.MyUserDetailService\"> &lt;/beans:bean> &lt;!-- 被认证请求根据所需权限跳转到不同的登录界面 --> &lt;beans:bean id=\"myAuthenticationEntryPoint\" class=\"org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint\"> &lt;beans:constructor-arg name=\"loginFormUrl\" value=\"/login.html\">&lt;/beans:constructor-arg> &lt;/beans:bean> &lt;!-- 验证成功后操作 --> &lt;beans:bean id=\"authenticationSuccessHandler\" class=\"com.seawin.webapp.base.security.MySimpleUrlAuthenticationSuccessHandler\" /> &lt;!-- 验证失败后操作 --> &lt;beans:bean id=\"authenticationFailureHandler\" class=\"com.seawin.webapp.base.security.MySimpleUrlAuthenticationFailureHandler\"> &lt;beans:property name=\"defaultFailureUrl\" value=\"/login.html\" /> &lt;/beans:bean> &lt;!-- 自定义登陆拦截器 --> &lt;beans:bean id=\"loginFilter\" class=\"com.seawin.webapp.base.security.MyAuthenticationFilter\"> &lt;beans:property name=\"authenticationManager\" ref=\"myAuthenticationManager\" /> &lt;beans:property name=\"filterProcessesUrl\" value=\"/j_spring_security_check\" /> &lt;!-- 认证成功用自定义类authenticationSuccessHandler处理 --> &lt;beans:property name=\"authenticationSuccessHandler\" ref=\"authenticationSuccessHandler\"/> &lt;beans:property name=\"authenticationFailureHandler\" ref=\"authenticationFailureHandler\"/> &lt;/beans:bean> &lt;!-- 自定义拦截器 --> &lt;beans:bean id=\"securityInterceptor\" class=\"com.seawin.webapp.base.security.MyAuthorizationFilter\"> &lt;beans:property name=\"authenticationManager\" ref=\"myAuthenticationManager\"/> &lt;beans:property name=\"accessDecisionManager\" ref=\"mysecurityAccessDecisionManager\"/> &lt;beans:property name=\"securityMetadataSource\" ref=\"secureResourceFilterInvocationDefinitionSource\" /> &lt;/beans:bean> &lt;beans:bean id=\"mysecurityAccessDecisionManager\" class=\"com.seawin.webapp.base.security.MyAccessDecisionManager\" /> &lt;beans:bean id=\"secureResourceFilterInvocationDefinitionSource\" class=\"com.seawin.webapp.base.security.MySecurityMetadataSource\" /> &lt;/beans:beans> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://jiubanmoli.github.io/categories/Spring-Security/"}],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://jiubanmoli.github.io/tags/Spring-Security/"}]},{"title":"关于断言机制(Assert)常用的方法","slug":"assert","date":"2019-01-20T10:23:40.582Z","updated":"2022-01-04T13:58:00.064Z","comments":true,"path":"2019/01/20/assert/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/assert/","excerpt":"","text":"(1) isTrue(boolean expression) isTrue(boolean expression, String message) 当 expression 不为 true 抛出异常； (2)notNull(Object object) 当 object 不为 null 时抛出异常，notNull(Object object, String message) 方法允许您通过 message 定制异常信息。和 notNull() 方法断言规则相反的方法是 isNull(Object object)/isNull(Object object, String message)，它要求入参一定是 null； (3)notEmpty(Collection collection) notEmpty(Collection collection, String message) 当集合未包含元素时抛出异常。 notEmpty(Map map) notEmpty(Map map, String message) notEmpty(Object[] array, String message) notEmpty(Object[] array, String message) 分别对 Map 和 Object[] 类型的入参进行判断； (4)hasLength(String text) hasLength(String text, String message) 当 text 为 null 或长度为 0 时抛出异常 (5)hasText(String text) hasText(String text, String message) text 不能为 null 且必须至少包含一个非空格的字符，否则抛出异常； (6)isInstanceOf(Class clazz, Object obj) isInstanceOf(Class type, Object obj, String message) 如果 obj 不能被正确造型为 clazz 指定的类将抛出异常； (7)isAssignable(Class superType, Class subType) isAssignable(Class superType, Class subType, String message) subType 必须可以按类型匹配于 superType，否则将抛出异常； document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Assert","slug":"Assert","permalink":"http://jiubanmoli.github.io/categories/Assert/"}],"tags":[{"name":"Assert","slug":"Assert","permalink":"http://jiubanmoli.github.io/tags/Assert/"}]},{"title":"Spring下ActiveMQ的xml配置","slug":"activemq","date":"2019-01-20T10:21:49.987Z","updated":"2022-01-04T13:58:00.039Z","comments":true,"path":"2019/01/20/activemq/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/activemq/","excerpt":"","text":"&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:cache=\"http://www.springframework.org/schema/cache\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.0.xsd\"> &lt;!--连接池 ActiveMQ为我们提供了一个PooledConnectionFactory，通过往里面注入一个ActiveMQConnectionFactory 可以用来将Connection、Session和MessageProducer池化，这样可以大大的减少我们的资源消耗,要依赖于 activemq-pool包 --> &lt;bean id=\"pooledConnectionFactory\" class=\"org.apache.activemq.pool.PooledConnectionFactory\" destroy-method=\"stop\"> &lt;property name=\"connectionFactory\"> &lt;bean class=\"org.apache.activemq.ActiveMQConnectionFactory\"> &lt;property name=\"brokerURL\" value=\"tcp://localhost:61616\" /> &lt;/bean> &lt;/property> &lt;/bean> &lt;!-- 连接工厂 --> &lt;bean id=\"activeMQConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"> &lt;property name=\"brokerURL\" value=\"tcp://localhost:61616\" /> &lt;!-- &lt;property name=\"brokerURL\" value=\"ws://localhost:61614\" /> --> &lt;/bean> &lt;!-- 配置消息目标 --> &lt;bean id=\"queryDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"> &lt;constructor-arg index=\"0\" value=\"greetings\" /> &lt;/bean> &lt;!-- 定义消息Destination --> &lt;bean id=\"topicDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"> &lt;constructor-arg value=\"/topic/greetings\"/> &lt;/bean> &lt;!-- 消息模板 --> &lt;bean id=\"queryJmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"> &lt;property name=\"connectionFactory\" ref=\"activeMQConnectionFactory\" /> &lt;property name=\"defaultDestination\" ref=\"queryDestination\" /> &lt;property name=\"messageConverter\"> &lt;bean class=\"org.springframework.jms.support.converter.SimpleMessageConverter\" /> &lt;/property> &lt;/bean> &lt;!-- 消息发送者客户端 --> &lt;bean id=\"topicJmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"> &lt;property name=\"connectionFactory\" ref=\"activeMQConnectionFactory\" /> &lt;property name=\"defaultDestination\" ref=\"topicDestination\" /> &lt;property name=\"messageConverter\"> &lt;bean class=\"org.springframework.jms.support.converter.SimpleMessageConverter\" /> &lt;/property> &lt;!-- 开启订阅模式 --> &lt;property name=\"pubSubDomain\" value=\"true\"/> &lt;property name=\"receiveTimeout\" value=\"10000\" /> &lt;!-- deliveryMode, priority, timeToLive 的开关要生效，必须配置为true，默认false--> &lt;property name=\"explicitQosEnabled\" value=\"true\"/> &lt;!-- 发送模式 DeliveryMode.NON_PERSISTENT=1:非持久 ; DeliveryMode.PERSISTENT=2:持久 --> &lt;property name=\"deliveryMode\" value=\"2\"/> &lt;/bean> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"http://jiubanmoli.github.io/categories/ActiveMQ/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://jiubanmoli.github.io/tags/Spring/"},{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"http://jiubanmoli.github.io/tags/ActiveMQ/"}]},{"title":"去掉Mybatis Generator生成的一堆Example类","slug":"mybatis-twleve","date":"2019-01-20T10:18:51.444Z","updated":"2022-01-04T13:58:00.111Z","comments":true,"path":"2019/01/20/mybatis-twleve/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mybatis-twleve/","excerpt":"","text":"上篇讲了如何使用Mybatis Generator生成代码，但是再生成过程中，往往出现一大堆的Example类，而这些Example中的很多方法我们是不需要用到的，因此在生成之前我们可以添加如下代码: &lt;table schema=\"general\" tableName=\"tb_table_name\" domainObjectName=\"EntityName\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\" > &lt;property name=\"useActualColumnNames\" value=\"true\"/> &lt;/table> 右击项目—&gt;run as—&gt;maven build就OK啦！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/tags/Mybatis/"}]},{"title":"MyBatis获取插入记录的自增长字段值","slug":"mybatis-eleven","date":"2019-01-20T10:13:27.197Z","updated":"2022-01-04T13:58:00.092Z","comments":true,"path":"2019/01/20/mybatis-eleven/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mybatis-eleven/","excerpt":"","text":"转自：http://blog.csdn.net/hellostory/article/details/6790248 1.在Mybatis Mapper文件中添加属性“useGeneratedKeys”和“keyProperty”，其中keyProperty是Java对象的属性名！&lt;insert id=\"insert\" parameterType=\"Spares\" useGeneratedKeys=\"true\" keyProperty=\"id\"> insert into spares(spares_id,spares_name, spares_type_id,spares_spec) values(#{id},#{name},#{typeId},#{spec}) &lt;/insert> 2.Mybatis执行完插入语句后，自动将自增长值赋值给对象Spares的属性id。因此，可通过Spares对应的getter方法获取！/** * 新增备件 * @author hellostory * @param spares * @return */ @RequestMapping(value = \"/insert\") @ResponseBody public JsonResponse insert(Spares spares) { int count = sparesService.insert(spares); System.out.println(\"共插入\" + count + \"条记录！\" + \"\\n刚刚插入记录的主键自增长值为：\" + spares.getId()); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/tags/Mybatis/"}]},{"title":"关于Mybatis出现:there is no getter for property named 'VARCHAR' in 'class com.xxx.xxxxx","slug":"mybatis-ten","date":"2019-01-20T10:11:13.019Z","updated":"2022-01-04T13:58:00.101Z","comments":true,"path":"2019/01/20/mybatis-ten/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mybatis-ten/","excerpt":"","text":"出现这个问题的时候我也是一脸懵逼，后面百度一下但都不是我出现的情况，下面说一下我的解决方法吧 之前看到是插入的时候语句没有截断加上逗号，后面运行一下项目发现还是出现同样的问题， 解决方案如下: 传入的参数我不小心写成了数据库的字段，所以导致冲突，参数应该是你传入的那个参数字段，如果你也出现这种问题还是仔细看看吧，我改正之后就没有以上情况了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/tags/Mybatis/"}]},{"title":"Navicat报文件名，目录名或建标语法不正确的解决办法","slug":"navicat-two","date":"2019-01-20T10:08:44.199Z","updated":"2022-01-04T13:58:00.118Z","comments":true,"path":"2019/01/20/navicat-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/navicat-two/","excerpt":"","text":"那天我打开Navicat Permium的时候，当我点击新建查询的时候给我弹出以上问题的框， 解决方案:删除连接，新建一个连接，测试，OK！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://jiubanmoli.github.io/categories/开发工具/"}],"tags":[{"name":"navicat","slug":"navicat","permalink":"http://jiubanmoli.github.io/tags/navicat/"}]},{"title":"Spring MVC中Date对象获取不到表单序列化传过来的日期值解决办法","slug":"springmvc-two","date":"2019-01-20T10:05:12.951Z","updated":"2022-01-04T13:58:00.140Z","comments":true,"path":"2019/01/20/springmvc-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/springmvc-two/","excerpt":"","text":"之前在做这一块的时候，由于js中将表单序列化转换成了json格式，而我使用实体对象直接获取值的，导致我这里出现取不到值的情况，为此，想了一天，用前端JSON.stringgify转换成了对象传给我还是取不到 我还采用了反序列化使用@JSONFiled和@JSONFormat两种方式但还是做无用功，也想到过将字段改成Strign类型，但是之后做转换很麻烦，因此因为这个伤了脑筋，不过最终努力还是有回报，问题得到了解决，下面说下 我的解决方法： 首先在实体类中在定义两个字段，并且赋给他getter和setter方法， 例如:我实体对象获取值的是ieDate和dDate;我在给他添加两个字段 private String ieDateStr; private String dDateStr; 然后把这两个字段放到文本框的name属性中， 在Controller中如下写: 将你获取到的值进行格式转换并且添加到你的Date字段当中就OK了! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://jiubanmoli.github.io/categories/SpringMVC/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jiubanmoli.github.io/tags/Web/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://jiubanmoli.github.io/tags/SpringMVC/"}]},{"title":"mybatis中返回list集合为空的解决方法","slug":"mybatis-nine","date":"2019-01-20T09:59:30.912Z","updated":"2022-01-04T13:58:00.099Z","comments":true,"path":"2019/01/20/mybatis-nine/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mybatis-nine/","excerpt":"","text":"一.本人出现的问题是sql语句没报错，但是由于忽略了已修改的代码的传递参数的值，导致查询出来的结果为空，在controller中的参数互换一下就有值了 二.用mybits查询数据库时，如果参数已传入sql，sql也已经执行了，但是返回结果为空，首先保证数据库中有对应数据，如果有对应数据仍返回null，是数据库配置文件有问题。解决方案如下： 1、mapper.xml文件加入映射，column是数据库中的字段名，property是实体类javabean中的属性，要一一对应 2、如果是多张表联合查询，查看是否有相同字段并且没有做区分，比如select s. from single left join customer cu on s.customer_id = cu.customer_id;single的customer_id没有指定，建议s. 换成指定字段 3、标签中不要用ResultType，要用ResultMap且名字要和属性的id相同。且select语句不要用”select * from user_info”,要用具体的字段名如”select user_id,user_name from user_info”`xml&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- 这里的id必须和UserMapper接口中的接口方法名相同,resultMap和上面定义的id名字相同 --&gt; &lt;select id=\"getUser\" resultMap=\"BaseResultMap\" parameterType=\"Java.lang.Integer\"&gt; select user_id,user_name from user_info where user_id=#{id} &lt;/select&gt; ` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/tags/Mybatis/"}]},{"title":"Mybatis批量插入转换成list集合的问题以及解决方案","slug":"mybatis-eight","date":"2019-01-20T09:56:06.916Z","updated":"2022-01-04T13:58:00.089Z","comments":true,"path":"2019/01/20/mybatis-eight/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mybatis-eight/","excerpt":"","text":"问题： 由于项目中需要批量插入的功能，然后我就用到了阿里的json包，将json数据转换成list集合在批量添加到数据库，但是这个过程中，我突然发现一个问题，之前接收前台传来的值是有的，但转换之后某些字段的值没有了，后面发现，原来是Mybatis自动生成插件做的怪，将实体类赋setter和getter方法时，并没有将属性大写，也就是说原本我的实体字段为gName;setter方法之后为setgName,这就违反了命名规则，但是阿里json包就出现了不能转换报Null的问题，经过试验，终于找到了解决方案： 解决方案： 1.如果你不想用别的方法，且Pojo类字段不是很多的话，直接将所有的setter和getter方法去掉，用eclipse自动生成的setter和getter方法 2.当然，这种方法是已经废弃的，但是还可以使用，至于有什么漏洞我就不知道了JSONArray Array1 = JSONArray.fromObject(Declaration); //List&lt;CustomsDeclareBillDetail> detail = Array1.toList(Array1, CustomsDeclareBillDetail.class); 3.这种方法的结果和上面是一样的，但还是极力推荐使用这种方案。JSONArray jsonArray = JSONArray.fromObject(json); List&lt;String> list2 = (List) JSONArray.toCollection(jsonArray); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/tags/Mybatis/"}]},{"title":"数据库是dateTime类型传入参数是String类型如何转换的解决方案","slug":"mybatis-seven","date":"2019-01-20T09:53:09.595Z","updated":"2022-01-04T13:58:00.103Z","comments":true,"path":"2019/01/20/mybatis-seven/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mybatis-seven/","excerpt":"","text":"最近遇到一个头疼的问题，在进行条件查询时发现查询没有结果，后面发现数据库字段是dateTime类型，而我传入的是String类型，这就导致它不识别你传入的参数无法作比较而爆出异常，在这里贴出本人的解决方案: create_time是你的数据库字段，我是做时间范围查询，因此使用了if高级判断，另外发现数据库另外一个字段是date类型，而我传入的是String类型并没有做转换还查询出了结果，这让我感到疑惑，最终可能是因为date的形式和传入参数的格式一致所以才能识别吧，但还是不建议使用。至于我这里为什么还指定了字段是因为我数据库使用了左连接，两个表有相同的字段所以需要指定否则识别不了还是没有查询结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/tags/Mybatis/"}]},{"title":"Mybatis条件查询没有结果，程序不继续执行的原因及解决方案","slug":"mybatis-six","date":"2019-01-20T09:49:46.916Z","updated":"2022-01-04T13:58:00.098Z","comments":true,"path":"2019/01/20/mybatis-six/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mybatis-six/","excerpt":"","text":"之前做条件查询的时候，遇到一个问题，如果查询条件数据库能查到，dataTable就给我返回数据，但如果查不到，程序就不执行了，为此也拜读了许多，但是没有搜索结果，有一个的他的事实体类中添加了构造方法后面去掉就解决了，但是我的不是，找了N久，终于解决了，问题出现在哪呢，我debug到查询出来的list，发现list是空的啊，那页面为啥一直在加载呢，而断点也没往下执行了，后面才发现，如图所示：我给list做了JSONObject.fromObject的转换，因此程序到这里就截止了，执行不下去了，后面我去掉了，直接放在map里，就解决了，更多的原因还是出在自己写的代码里，还是要观细微啊！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/tags/Mybatis/"}]},{"title":"Mybatis实现批量插入与批量删除案例","slug":"mybatis-five","date":"2019-01-20T09:46:01.166Z","updated":"2022-01-04T13:58:00.094Z","comments":true,"path":"2019/01/20/mybatis-five/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mybatis-five/","excerpt":"","text":"1.js：首先序列化表单然后将值传到后台 2.Controller： 获取前台传来的序列化表单，并转化为List集合： 3.Service以及ServiceImpl层： 4.Mybatis: 字段以及数据库类型一定要对应 批量插入: &lt;insert id=\"insertBatch\" parameterType=\"java.util.Map\"> insert into customs_declare_bill_detail( id, gno, relman_no, code_t, g_name, g_model, g_qty, g_unit, decl_total, decl_curr, decl_price, exg_version, goods_no, origin_country, unit_1, qty_1, unit_2, qty_2, duty_mode, work_usd, dest_country, rtn_code, rtn_info, invalid, bill_id, main_factor, bill_no, creator, create_time, amender, amend_time) values &lt;foreach collection=\"list\" item=\"item\" index=\"index\" separator=\",\"> ( #{item.id,jdbcType=BIGINT}, #{item.gno,jdbcType=VARCHAR}, #{item.relmanNo,jdbcType=VARCHAR}, #{item.codeT,jdbcType=VARCHAR}, #{item.gName,jdbcType=VARCHAR}, #{item.gModel,jdbcType=VARCHAR}, #{item.gQty,jdbcType=INTEGER}, #{item.gUnit,jdbcType=VARCHAR}, #{item.declTotal,jdbcType=DECIMAL}, #{item.declCurr,jdbcType=VARCHAR}, #{item.declPrice,jdbcType=DECIMAL}, #{item.exgVersion,jdbcType=VARCHAR}, #{item.goodsNo,jdbcType=VARCHAR}, #{item.originCountry,jdbcType=VARCHAR}, #{item.unit1,jdbcType=VARCHAR}, #{item.qty1,jdbcType=DECIMAL}, #{item.unit2,jdbcType=VARCHAR}, #{item.qty2,jdbcType=DECIMAL}, #{item.dutyMode,jdbcType=VARCHAR}, #{item.workUsd,jdbcType=DECIMAL}, #{item.destCountry,jdbcType=VARCHAR}, #{item.rtnCode,jdbcType=VARCHAR}, #{item.rtnInfo,jdbcType=VARCHAR}, #{item.invalid,jdbcType=VARCHAR}, #{item.billId,jdbcType=BIGINT}, #{item.mainFactor,jdbcType=VARCHAR}, #{item.billNo,jdbcType=VARCHAR}, #{item.creator,jdbcType=INTEGER}, #{item.createTime,jdbcType=TIMESTAMP}, #{item.amender,jdbcType=INTEGER}, #{item.amendTime,jdbcType=TIMESTAMP} ) &lt;/foreach> &lt;/insert> 2.批量删除: &lt;delete id=\"deleteById\" parameterType=\"java.lang.String\"> delete from customs_declare_bill_detail where id in &lt;foreach item=\"item\" index=\"index\" collection=\"array\" open=\"(\" separator=\",\" close=\")\"> #{item} &lt;/foreach> &lt;/delete> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/tags/Mybatis/"}]},{"title":".metadata\\.plugins\\org.eclipse.wst.server.core\\tmp0\\wtpwebapps\\ipact\\.\\upload\\*.txt问题及解决方案","slug":"javaweb-four","date":"2019-01-20T09:42:13.693Z","updated":"2022-01-04T13:58:00.075Z","comments":true,"path":"2019/01/20/javaweb-four/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/javaweb-four/","excerpt":"","text":"这是没有设置路径，所以eclipse将默认路径到了eclipse自带的Tomcat下面 解决方式: tomcat有项目的先remove掉，双击tomcat,旁边有一个Server Locations 这里有三种可以选择： 1.使用eclipse的工作空间，以上述为例就是 D:\\workSpace.metadata.plugins\\org.eclipse.wst.server.core\\tmp0\\ 2.使用tomcat的安装目录，以上述为例就是 D:\\tomcat\\ 3.自定义路径，这里就是自己选择目录了 还可以通过修改 Deploy path 来定义工程到底部署到容器的哪个目录下。例如下图中，我们就可以选着 Use Tomcat Installtion 这种方式，并且设置 Deploy path 为 webapps: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/tags/Java-Web/"}]},{"title":"is a MultipartResolver configured?","slug":"javaweb-three","date":"2019-01-20T09:39:47.331Z","updated":"2022-01-04T13:58:00.079Z","comments":true,"path":"2019/01/20/javaweb-three/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/javaweb-three/","excerpt":"","text":"解决方法：（1）第一步：引入commons-fileupload-1.2.jar，具体版本号以具体项目要求为准；第二步：在spring-mvc.xml中增加如下配置，具体文体大小限制以具体项目要求为准 &lt;!-- 设置上传文件最大值 1M=1*1024*1024(B)=1048576 bytes --> &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"> &lt;property name=\"maxUploadSize\" value=\"1048576\" /> &lt;/bean> （2）我是在Controller中的方法加了@RequestParam(“file”)Mutipart file,但是我spring.xml中引用的是自定义的包，不是spring本体的包，所以报错了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/tags/Java-Web/"}]},{"title":"BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContext的出现问题以及各种解决方案","slug":"javaweb-two","date":"2019-01-20T09:36:36.851Z","updated":"2022-01-04T13:58:00.078Z","comments":true,"path":"2019/01/20/javaweb-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/javaweb-two/","excerpt":"","text":"解决方案: (1) BeanFactory没有实例化或者已经关闭了，其实产生错误的原因很简单，在写：ApplicationContext ctx = new ClassPathXmlApplicationContext();时，没有指定配置文件，Spring实例化BeanFactory的时候是默认到classPath下面查找名为applicationContext.xml的文件的，但是呢，你又没有指定，所以出现了这个错误。 这就是错误的原因，在括号写上配置文件名就行了。 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 这样的话就不会出现这样的错误了。 (2) 原因：spring初始化bean对象出错； 1）xml的bean的id 有重复； 2）如果是注解配置：可能是注解的名称有重复： 只需要将重复的bean 的id和重复的注解改了就行了； （3）查看@Controller或者@service注入的接口是否有一样的或者注入的接口是引入别的文件的而导致报错(本人项目出错原因) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/tags/Java-Web/"}]},{"title":"java生成自增流水号，并从每月第一天重新清零计数将业务流水号添加到数据库","slug":"javaweb","date":"2019-01-20T09:32:54.848Z","updated":"2022-01-04T13:58:00.081Z","comments":true,"path":"2019/01/20/javaweb/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/javaweb/","excerpt":"","text":"如果你不想在数据库操作的话，这里有个方法可以一试，直接上代码: package com.seawin.common.util.convert; import java.text.DecimalFormat; import java.text.SimpleDateFormat; import java.util.Date; public class PrimaryGenerater { private static String SERIAL_NUMBER = \"0001\" ; private static PrimaryGenerater primaryGenerater = null; private PrimaryGenerater(){ } /** * 取得PrimaryGenerater的单例实现 * * @return */ public static PrimaryGenerater getInstance() { if (primaryGenerater == null) { synchronized (PrimaryGenerater.class) { if (primaryGenerater == null) { primaryGenerater = new PrimaryGenerater(); } } } return primaryGenerater; } /** * 生成 日期+随机数的流水号 * */ public String getNumberForPK(){ String id=\"\"; SimpleDateFormat sf = new SimpleDateFormat(\"yyyyMMddHHmmss\"); String temp = sf.format(new Date()); int random=(int) (Math.random()*10000); id=temp+random; return id; } /** * HHTG+年月+8+0001 * 每月从0001开始计数 * */ public static synchronized String getnumber(String thisCode){ String id = null; Date date = new Date(); SimpleDateFormat formatter = new SimpleDateFormat(\"yyMM\"); String thisData = thisCode.substring(4, 8); //这个判断就是判断你数据取出来的最后一个业务单号是不是当月的 if(!formatter.format(date).equals(thisData)){ System.out.println(\"新的一月\"); thisData = formatter.format(date); //如果是新的一月的就直接变成0001 id = \"HHTG\" + thisData + \"80001\"; }else{ System.out.println(\"当月\"); DecimalFormat df = new DecimalFormat(\"0000\"); //不是新的一月就累加 id =\"HHTG\"+ formatter.format(date)+\"8\" + df.format(1 + Integer.parseInt(thisCode.substring(9, 13))); } return id; } public static void main(String[] args){ /** * HHTG170980001 * HH公司简称 + TG业务类型 + 年月 + 8部门 + 0001 * * */ String sno = \"HHTG170980001\"; System.out.println(getnumber(sno)); } } Controller调用： no = list.get(0).getBillSeq()这里是查看你数据库的本月最后一条记录，如果有，则继续增加，如果是新月份，则从0001开始计数 结果如下: 换下月份结果如下: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/tags/Java-Web/"}]},{"title":"关于对springboot的认识","slug":"springboot-two","date":"2019-01-20T09:27:25.945Z","updated":"2022-01-04T13:58:00.130Z","comments":true,"path":"2019/01/20/springboot-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/springboot-two/","excerpt":"","text":"什么是spring bootSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是spring boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适） 使用spring boot有什么好处其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢 1）配置web.xml，加载spring和spring mvc 2）配置数据库连接、配置spring事务 3）配置加载配置文件的读取，开启注解 4）配置日志文件 … 配置完成之后部署tomcat 调试 … 现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍! 但是如果使用spring boot呢？很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！ 使用sping boot到底有多爽，用下面这幅图来表达 链接： http://www.ityouknow.com/springboot/2016/01/06/springboot(%E4%B8%80)-%E5%85%A5%E9%97%A8%E7%AF%87.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jiubanmoli.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jiubanmoli.github.io/tags/SpringBoot/"}]},{"title":"mysql连接报too many connections以及打开mysql.exe出现闪退的问题","slug":"mysql-five","date":"2019-01-20T09:23:04.244Z","updated":"2022-01-04T13:58:00.106Z","comments":true,"path":"2019/01/20/mysql-five/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mysql-five/","excerpt":"","text":"1.打开cmd,进入mysql盘，进入mysql所在文件夹，进入bin文件夹 2.输入net start mysql启动MySQL服务 3.输入 show variables like '%max_connections%'; 4.结果显示： 5.设置最大连接数: set global max_connections=1000； 6.启动tomcat，ok document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://jiubanmoli.github.io/categories/MYSQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://jiubanmoli.github.io/tags/mysql/"}]},{"title":"ajax获取返回的map集合","slug":"ajax","date":"2019-01-20T09:15:56.516Z","updated":"2022-01-04T13:58:00.059Z","comments":true,"path":"2019/01/20/ajax/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/ajax/","excerpt":"","text":"后台代码: 或: 前台ajax获取: (1)第一种: （2）第二种: （3）第三种：in循环 (4)第四种：for循环 (5)第五种:each循环 链接：http://blog.csdn.net/t0404/article/details/53425417 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"HTML","slug":"HTML","permalink":"http://jiubanmoli.github.io/categories/HTML/"}],"tags":[{"name":"html","slug":"html","permalink":"http://jiubanmoli.github.io/tags/html/"},{"name":"jquery","slug":"jquery","permalink":"http://jiubanmoli.github.io/tags/jquery/"}]},{"title":"Mysql存储过程，函数，视图，触发器的用法","slug":"mysql-four","date":"2019-01-20T09:09:27.910Z","updated":"2022-01-04T13:58:00.109Z","comments":true,"path":"2019/01/20/mysql-four/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mysql-four/","excerpt":"","text":"存储过程 1语法 CREATE PROCEDURE sp_name ([proc_parameter[,...]]) [characteristic ...] routine_body 2举例 DROP PROCEDURE IF EXISTS pro_add; DELIMITER // CREATE PROCEDURE pro_add( IN p1 INT, IN p2 INT, INOUT p3 INT) BEGIN SET p3=p1+p2; END // CALL pro_add(1,2,@abc); SELECT @abc; 函数 （特殊的存储过程 暂时不支持 out） 1语法结构： CREATE FUNCTION sp_name ([func_parameter[,...]]) RETURNS type [characteristic ...] routine_body 2举例 DROP FUNCTION IF EXISTS fun_add; DELIMITER // CREATE FUNCTION fun_add(p1 INT,p2 INT) RETURNS INT BEGIN RETURN p1+p2; END // SET @abc=fun_add(1,2); SELECT @abc; 视图 1&gt;语法结构 create view 名称 as sql语句 视图操作举例CREATE TABLE `arcticle` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(200) DEFAULT NULL, `content` varchar(200) DEFAULT NULL, `createuser` varchar(200) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 CREATE VIEW vi_arc AS SELECT title,content FROM arcticle SELECT * FROM arcticle UPDATE vi_arc SET content='java永不过时' WHERE title='java是否过时' DELETE FROM vi_arc WHERE title='java是否过时' INSERT INTO vi_arc VALUES('abc','ccc') 触发器 1&gt;语法结构 CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 2&gt;举例： DROP TRIGGER trg_arc DELIMITER // CREATE TRIGGER trg_arc BEFORE INSERT ON arcticle FOR EACH ROW BEGIN IF new.createuser IS NULL THEN SET new.createuser='张三'; END IF; END // 3&gt;注意 delete和update 有 old对象 insert和update 有new对象 update 有old，new对象 after触发器 不能够修改new的值 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://jiubanmoli.github.io/categories/MYSQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://jiubanmoli.github.io/tags/mysql/"}]},{"title":"Windows Mysql 5.7.15 主从复制","slug":"mysql-three","date":"2019-01-20T09:02:06.156Z","updated":"2022-01-04T13:58:00.115Z","comments":true,"path":"2019/01/20/mysql-three/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mysql-three/","excerpt":"","text":"Windows Mysql 5.7.15 主从复制 Windows MySQL 解压版安装 1、配置环境变量 2、解压出来的目录默认会有my-default.ini，该配置文件主要用于配置 basedir = D:\\soft\\mysql-5.7.15-winx64datadir = D:\\soft\\mysql-5.7.15-winx64\\bin在安装目录下新建data目录 3、打开dos窗口执行命令，进入mysql安装目录的bin目录下，执行mysqld --initialize-insecure --user=mysqlmysqld install执行后Windows服务中就会有MySQL的服务，然后执行net start mysql会出现提示，服务启动成功 4、服务启动成功后，输入 mysql -uroot -p 直接进入mysql，这是因为安装后第一次不需要输入密码，进入后需要修密码SET PASSWORD FOR ‘root‘@’localhost’ = PASSWORD(‘newpass’)`;到这里MySQL数据库安装完毕。接下来我们进行主从复制的配置 Windows MySQL5.7.15 主从复制配置 1、主从服务器配置一样建立用户`mysql&gt; grant all privileges on . to root@”192.168.0.161” identified by “root”;Query OK, 0 rows affected (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) - 2、配置环境变量my.ini 解压版的默认没有my.ini配置文件，只有my-default.ini文件， 这样只需新建my.ini文件即可，然后配置 Master 添加如下 [mysqld]log-bin=mysql-binlog-bin-index=mysql-bin.indexserver-id = 232sync_binlog=1binlog_format=mixedbinlog-do-db = ibase4jbinlog-ignore-db = mysqlbinlog-ignore-db = performance_schemabinlog-ignore-db = information_schema #服务端的编码方式 character-set-server=utf8 #客户端编码方式，最好和服务端保存一致 loose-default-character-set = utf8 [mysqldump]max_allowed_packet = 100M Slave 添加如下 [mysqld]server-id = 148log-bin=mysql-binrelay-log-index = slave-relay-bin.indexrelay-log = slave-relay-bin sync_master_info = 1sync_relay_log = 1sync_relay_log_info = 1 #服务端的编码方式character-set-server=utf8 #客户端编码方式，最好和服务端保存一致loose-default-character-set = utf8 3、重启服务 主服务器重启后 登录mysql，执行`show master status`; mysql&gt; show master status; +------------------+----------+--------------+---------------------------------- -----------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +------------------+----------+--------------+---------------------------------- -----------+ | mysql-bin.000004 | 107 | ibase4j | mysql,performance_schema,informat ion_schema | +------------------+----------+--------------+---------------------------------- -----------+ 从服务器重启 重启后登录从服务器 mysql&gt; slave stop;Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&gt; change master to master_host=’192.168.0.19’,master_user=’root’,master_password=’root’,master_log_file=’mysql-bin.000001’ ,master_log_pos=5163;Query OK, 0 rows affected (0.04 sec) mysql&gt; slave start;Query OK, 0 rows affected (0.00 sec) 注意查看： Slave_IO_Running: YesSlave_SQL_Running: Yes`以上这两个参数的值为Yes，即说明配置成功！ 第四部：测试MySQL主从服务器双机热备是否成功在主服务器上的mysql中添加数据、或表，看能否同步到从服务器中的mysql中。 问题:查看Slave状态：show slave status\\GSlave_IO_Running: connecting —网络不通Slave_SQL_Running: NO： 原因： 1.程序可能在slave上进行了写操作 2.也可能是slave机器重起后，事务回滚造成的. 解决办法： 1.首先停掉Slave服务：slave stop 2.到主服务器上查看主机状态：记录File和Position对应的值。 3.到slave服务器上执行手动同步： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://jiubanmoli.github.io/categories/MYSQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://jiubanmoli.github.io/tags/mysql/"}]},{"title":"Eclipse导入maven项目报Resources文件夹红叉问题解决方案","slug":"eclipse","date":"2019-01-20T08:56:13.159Z","updated":"2022-01-04T13:58:00.066Z","comments":true,"path":"2019/01/20/eclipse/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/eclipse/","excerpt":"","text":"1.找到该项目下的settings文件夹， 2.找到该文件 3.打开查看版本号 与web.xml文件中的版本号做对比 4.然后在Eclipse中点击该项目maven update Project， OK！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://jiubanmoli.github.io/categories/开发工具/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://jiubanmoli.github.io/tags/eclipse/"},{"name":"maven","slug":"maven","permalink":"http://jiubanmoli.github.io/tags/maven/"}]},{"title":"SSM框架实现复杂的Excel导出功能","slug":"ssm-two","date":"2019-01-20T08:48:05.954Z","updated":"2022-01-04T13:58:00.142Z","comments":true,"path":"2019/01/20/ssm-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/ssm-two/","excerpt":"","text":"最近项目开发当中要求实现导出功能，查看了很多人的博客但是感觉对于复杂的导出还是感觉好麻烦，代码量太大，为此，想了多种方法，最后找到了最简洁的一种方法，如下： 1.要实现的导出功能模板如下： 2.按常规解决方法做如下导出显然是不明智的，为此，Java中提供了一个jar包可以实现这种复杂的导出 3.导入jxls包 4.在Controller中代码如下： (1)首先实现数据查询 (2)获取项目中放入Excel模板的路径以及导出Excel的路径 (3)将项目路径放入读取流，导出路径以及文件名放入输出流，然后用Map实现key-value的方式写入Excel，此处的list和Detail是查询出来的结果集，然后就是用我们导入的jar包功能啦，使用XLSTransformer，将结果集写入Excel，然后在获取导出的文件路径，在客户端实现下载导出的功能 4.Excel模板如下，此处必须用${key.value}输出值的方式，否则无效 5.附上源代码： @RequestMapping(value = \"/export.do\",produces=\"text/html;charset=utf-8\") @ResponseBody public void export(HttpServletRequest req,HttpServletResponse response) throws Exception { Long id = (long) Integer.parseInt(req.getParameter(\"id\")); List&lt;CustomsDeclareBill> list = customsDeclareBillService.selectByPrimaryKey(id); List&lt;CustomsDeclareBillDetail> detail = customsDeclareBillDetailService.getSelectDetailById(list.get(0).getId()); if(list!=null &amp;&amp; !list.isEmpty()||detail!=null&amp;&amp;!detail.isEmpty()){ InputStream is = null; OutputStream os = null; try { //文件名 String excelName = \"中华人民共和国海关进口货物报关单.xls\"; excelName = java.net.URLDecoder.decode(excelName,\"utf-8\"); //获取Excel模板的路径 /** * 获取项目路径 * 1.this.getClass().getClassLoader().getResource(\"/\").getPath(); * getClass().getProtectionDomain().getCodeSource().getLocation().getPath(); * 2.req.getSession().getServletContext().getRealPath(\"/resources/upload\"); * 3.servletContext.getRealPath(\"/\").substring(0, servletContext.getRealPath(\"/\").lastIndexOf(\"seawin-webapp-base\")) * */ //String templateDir = \"C:/Users/Administrator/Desktop/\"+java.net.URLDecoder.decode(excelName,\"utf-8\"); String templateDir =servletContext.getRealPath(\"/\").substring(0, servletContext.getRealPath(\"/\").lastIndexOf(\"seawin-webapp-base\"))+\"/seawin-pcweb/\"+\"/exceltemplates/\" ; //导出Excel路径 String exportDir=servletContext.getRealPath(\"/\").substring(0, servletContext.getRealPath(\"/\").lastIndexOf(\"seawin-webapp-base\"))+\"/seawin-uploadfile/\"; //设置响应 response.setCharacterEncoding(\"utf-8\"); response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + new String(excelName.getBytes(), \"ISO-8859-1\")); response.setContentType(\"application/vnd.ms-excel;charset=utf-8\"); is = new FileInputStream(templateDir+excelName); os = new FileOutputStream(exportDir+excelName); Map&lt;String,Object> beans = new HashMap&lt;String,Object>(); beans.put(\"billlist\", list); beans.put(\"detail\", detail); XLSTransformer transFormer = new XLSTransformer(); HSSFWorkbook workBook = (HSSFWorkbook) transFormer.transformXLS(is, beans); workBook.write(os); File file = new File(exportDir+File.separator+excelName); InputStream inputstream = null; if(file!=null){ inputstream = new FileInputStream(file); //用于记录以完成的下载的数据量，单位是byte long downloadedLength = 0l; os=response.getOutputStream(); //循环写入输出流 byte[] b = new byte[2048]; int length; while ((length = inputstream.read(b)) > 0) { os.write(b, 0, length); downloadedLength += b.length; } } os.flush(); inputstream.close(); is.close(); os.close(); } catch (InvalidFormatException e) { e.printStackTrace(); }catch (Exception e) { e.printStackTrace(); } } } 好了，这样就可以实现导出功能了，再复杂的Excel导出使用此种方式都能够化繁为简，喜欢的小伙伴就将此文顶上去让更多人看到吧！ 链接：http://blog.csdn.net/hu_shengyang/article/details/6736789，该链接写的很详细哦，并且可以实现往Excel中插入动态图片等等。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SSM","slug":"SSM","permalink":"http://jiubanmoli.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://jiubanmoli.github.io/tags/SSM/"}]},{"title":"check the manual that corresponds to your MySQL server version for the right syntax to use near 'null' at line 84","slug":"mybatis-four","date":"2019-01-20T08:45:50.449Z","updated":"2022-01-04T13:58:00.095Z","comments":true,"path":"2019/01/20/mybatis-four/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mybatis-four/","excerpt":"","text":"做mybatis批量插入的时候一直报这个错误，为此找了很久， 一直报着附近的错，后面发现是foreach后面括号没有添加，搞得我心累，所以还是粗心犯的错误， 出现这个错误肯定是sql语法的问题，建议仔细检查每一个环节才能找出错误 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jiubanmoli.github.io/tags/Mybatis/"},{"name":"Mysql","slug":"Mysql","permalink":"http://jiubanmoli.github.io/tags/Mysql/"}]},{"title":"405 method not allowed","slug":"405","date":"2019-01-20T08:42:11.663Z","updated":"2022-01-04T13:57:59.990Z","comments":true,"path":"2019/01/20/405/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/405/","excerpt":"","text":"之前项目开发的时候就遇到这种问题，百度了没啥结果，后面自己慢慢寻找错误终于发现了 ，现在总结一下： 1. 检查提交方式和接口路径是否与后台一一对应 2.如果前面没有问题，还是报错请查看指定方式 3.如果是新建的Controller，请检查spring.xml文件是否进行了配置扫描包 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"405","slug":"405","permalink":"http://jiubanmoli.github.io/tags/405/"}]},{"title":"SSM框架实现xml导出并在客户端下载的三种方式","slug":"ssm","date":"2019-01-20T08:31:20.126Z","updated":"2022-01-04T13:58:00.150Z","comments":true,"path":"2019/01/20/ssm/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/ssm/","excerpt":"","text":"1.使用Document创建节点 // 创建xml Document document = DocumentHelper.createDocument(); //创建节点 Element elements = document.addElement(\"ImportMessage\").addNamespace(\"xsi\",\"http://www.w3.org/2001/XMLSchema-instance\").addAttribute(\"xsi:noNamespaceSchemaLocation\",\"SWImportMessagexsd.xsd\"); 注:第一个是创建根节点，addNamespace()定义命名空间，后面一个就是自定义属性，如下图所示： //创建子节点 -----创建第一个子节点 Element ele = elements.addElement(\"Head\"); Element nameEle = ele.addElement(\"CopMsgId\").addText(\"普通报关单.xml\"); nameEle = ele.addElement(\"MsgType\").addText(\"SWDEC001\"); nameEle = ele.addElement(\"FunctionCode\").addText(\"0\"); nameEle = ele.addElement(\"Format\").addText(\"xml\"); nameEle = ele.addElement(\"Compress\").addText(\"0\"); nameEle = ele.addElement(\"Version\").addText(\"1.0\"); 如图所示: /*创建第二个子节点*/ Element ele2 = elements.addElement(\"Data\"); /*创建第二个子节点的子节点*/ Element nameEle2 = ele2.addElement(\"DecMessage\"); /*创建子节点的子节点*/ Element nameEle3 = nameEle2.addElement(\"DecLists\"); nameEle3 = nameEle2.addElement(\"DecContainers\"); nameEle3 = nameEle2.addElement(\"DecLicenseDocus\"); //获取所有的节点名称 Element root = document.getRootElement(); /*创建子节点下的节点循环，例如DecLists*/ for (CustomsDeclareBillDetail detail:detailList) { //找到要创造节点循环的子节点名称:root.selectSingleNode() Element ee2 = (Element) root.selectSingleNode(\"//DecLists\"); //创建节点循环的节点名称 Element ele6 = ee2.addElement(\"DecList\"); } Element ele7=ele7=ele6.addElement(\"商品编号\").addText(XMLUtil.replaceNullString(detail.getCodeT())); ele7=ele6.addElement(\"备案序号\").addText(XMLUtil.replaceNullString(detail.getRelmanNo())); ele7=ele6.addElement(\"商品名称\").addText(XMLUtil.replaceNullString(detail.getGName())); ele7=ele6.addElement(\"规格型号\").addText(XMLUtil.replaceNullString(detail.getgModel())); ele7= ele6.addElement(\"成交数量\").addText(XMLUtil.replaceNullString(detail.getgQty()==null?\"\":detail.getgQty().toString())); ele7= ele6.addElement(\"成交单位\").addText(XMLUtil.replaceNullString(detail.getGUnit())); ele7= ele6.addElement(\"法定单位\").addText(XMLUtil.replaceNullString(detail.getLegalUnits())); ele7= ele6.addElement(\"成交总价\").addText(XMLUtil.replaceNullString(detail.getDeclTotal()==null?\"\":detail.getDeclTotal().toString())); ele7= ele6.addElement(\"币制\").addText(XMLUtil.replaceNullString(detail.getDeclCurr())); ele7= ele6.addElement(\"原产国\").addText(XMLUtil.replaceNullString(detail.getOriginCountry())); ele7= ele6.addElement(\"征减免税方式\").addText(XMLUtil.replaceNullString(detail.getDutyMode())); ele7= ele6.addElement(\"最终目的国\").addText(XMLUtil.replaceNullString(detail.getDestCountry())); ele7= ele6.addElement(\"提运单号\").addText(XMLUtil.replaceNullString(detail.getBillNo())); } String xmlString = document.asXML(); String xmlDoc = XMLUtil.formatXml(xmlString); String fileName = \"报关单.xml\"; XMLUtil.getXMLWriter(response, fileName,xmlDoc); 如下图所示: 2.使用StringBuffer拼接xml文件： System.getProperty(“line.separator”);//为换行标记 StringBuffer buffer = new StringBuffer(); buffer.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;ImportMessage xsi:noNamespaceSchemaLocation=\\\"SWImportMessagexsd.xsd\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\">\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;Head>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;CopMsgId>普通报关单.xml&lt;/CopMsgId>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;MsgType>SWDEC001&lt;/MsgType>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;FunctionCode>0&lt;/FunctionCode>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;Format>xml&lt;/Format>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;Compress>0&lt;/Compress>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;Version>1.0&lt;/Version>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;/Head>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;Data>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;DecMessage>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;DecLists>\"+System.getProperty(\"line.separator\")); for (CustomsDeclareBillDetail detail:detailList) { buffer.append(\"&lt;DecList>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;商品编号>\"+detail.getCodeT()+\"&lt;/商品编号>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;备案序号>\"+detail.getRelmanNo()+\"&lt;/备案序号>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;商品名称>\"+detail.getGName()+\"&lt;/商品名称>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;规格型号>\"+detail.getgModel()+\"&lt;/规格型号>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;成交数量>\"+XMLUtil.replaceNullString(detail.getgQty()==null?\"\":detail.getgQty().toString())+\"&lt;/成交数量>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;成交单位>\"+detail.getGUnit()+\"&lt;/成交单位>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;法定单位>\"+detail.getLegalUnits()+\"&lt;/法定单位>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;成交总价>\"+XMLUtil.replaceNullString(detail.getDeclTotal()==null?\"\":detail.getDeclTotal().toString())+\"&lt;/成交总价>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;币制>\"+detail.getDeclCurr()+\"&lt;/币制>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;原产国>\"+detail.getOriginCountry()+\"&lt;/原产国>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;征减免税方式>\"+detail.getDutyMode()+\"&lt;/征减免税方式>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;最终目的国>\"+detail.getDestCountry()+\"&lt;/最终目的国>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;提运单号>\"+detail.getBillNo()+\"&lt;/提运单号>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;/DecList>\"+System.getProperty(\"line.separator\")); } buffer.append(\"&lt;/DecLists>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;/DecMessage>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;/Data>\"+System.getProperty(\"line.separator\")); buffer.append(\"&lt;/ImportMessage>\"); String xmlString = buffer.toString(); String xmlDoc = XMLUtil.formatXml(xmlString); String fileName = \"报关单.xml\"; XMLUtil.getXMLWriter(response, fileName,xmlDoc); 3.使用String += 输出xml文件: string strXML = \"&lt;?xml version=\\\"1.0\\\"?>\"; strXML+=\"&lt;books>&lt;bookdata id=\\\"1\\\">\"; strXML+=\"&lt;title>C# premier&lt;/title>\"; strXML += \"&lt;year>2005&lt;/year>\"; strXML+=\"&lt;publisher> Qinghua University Press&lt;/publisher>\"; strXML+=\"&lt;Author>hou &lt;/Author>\"; strXML+=\"&lt;pagers>500 &lt;/pagers>\"; strXML+=\"&lt;description> c# fundation knowledge&lt;/description>\"; strXML+=\"&lt;Price>50.00&lt;/Price>\"; strXML+=\"&lt;/bookdata>\"; strXML+=\"&lt;bookdata id=\\\"2\\\">\"; strXML+=\"&lt;title>xml premier&lt;/title>\"; strXML+=\"&lt;year>2005&lt;/year>\"; strXML+=\"&lt;publisher> Peking University Press&lt;/publisher>\"; strXML+=\"&lt;Author>Leo &lt;/Author>\"; strXML+=\"&lt;pagers>400 &lt;/pagers>\"; strXML+=\"&lt;description> xml fundation knowledge&lt;/description>\"; strXML+=\"&lt;Price>45.00&lt;/Price>\"; strXML+=\"&lt;/bookdata>\"; strXML+=\"&lt;bookdata id=\\\"3\\\">\"; strXML+=\"&lt;title>UML&lt;/title>\"; strXML+=\"&lt;year>2005&lt;/year>\"; strXML+=\"&lt;publisher> Peking University Press&lt;/publisher>\"; strXML+=\" &lt;Author>James &lt;/Author>\"; strXML+=\" &lt;pagers>650 &lt;/pagers>\"; strXML+=\" &lt;description>UML fundation knowledge&lt;/description>\"; strXML += \" &lt;Price>85.00&lt;/Price>\"; strXML+=\" &lt;/bookdata>&lt;/books>\"; Response.ContentType = \"text/xml\"; Response.Charset = \"UTF-8\"; System.Xml.XmlDocument doc = new System.Xml.XmlDocument(); doc.LoadXml(strXML); doc.Save(Response.OutputStream); Response.End(); /*或者这样也可以输出 *String xmlDoc = XMLUtil.formatXml(strXML); *String fileName = \"报关单.xml\"; *XMLUtil.getXMLWriter(response, fileName,xmlDoc); */ 最后附上调用的工具包: public class XMLUtil { private final static org.slf4j.Logger logger = LoggerFactory.getLogger(XMLUtil.class); private XMLUtil() { } /** * 根据字符串创建 document 对象 * * @param xmlStr * @return */ public static Document getDocumentByString(String xmlStr) { Document doc = null; try { doc = DocumentHelper.parseText(xmlStr); } catch (DocumentException e) { logger.error(\"字符串转换成XML失败:\" + e.getMessage()); } return doc; } /** * 设置response的返回信息 * @param response * @param fileName * @return XMLWriter */ public static XMLWriter getXMLWriter(HttpServletResponse response,String fileName,String xmlDoc) { XMLWriter writer = null; OutputStream os = null; try { //定义xml文件的格式 OutputFormat format = OutputFormat.createPrettyPrint(); format.setEncoding(\"UTF-8\"); //准备输出xml文件 writer =new XMLWriter(response.getOutputStream(),format); response.setContentType(\"text/xml;charset=UTF-8\"); response.setHeader(\"Content-disposition\", \"attachment;filename=\" + new String(fileName.getBytes(), \"iso-8859-1\")); os = response.getOutputStream(); os.write(xmlDoc.getBytes(\"UTF-8\")); writer.setOutputStream(os); }catch (Exception e){ logger.error(\"导出xml时获取XMLWriter出错：\"+e); }finally { if(null != os){ try { os.close(); } catch (IOException e) { logger.error(\"关闭outputStream出错：\"+e); } } } return writer; } public static String formatXml(String xml) throws DocumentException, IOException{ SAXReader saxReader = new SAXReader(); Document document = saxReader.read(new ByteArrayInputStream(xml.getBytes())); //创建输出格式 OutputFormat format = OutputFormat.createPrettyPrint(); //制定输出xml的编码类型 format.setEncoding(\"UTF-8\"); StringWriter writer = new StringWriter(); //创建一个文件输出流 XMLWriter xmlwriter = new XMLWriter(writer, format); //将格式化后的xml串写入到文件 xmlwriter.write(document); String returnValue = writer.toString(); writer.close(); //返回编译后的字符串格式 return returnValue; } /** * 根据file获得Document * @param file MultipartFile * @return Document */ public static Document getDocumentByFile(MultipartFile file){ File file1 = new File(file.getOriginalFilename()); Document document = null; try { file.transferTo(file1); //创建SAXReader对象 SAXReader reader = new SAXReader(); //读取文件 转换成Document document = reader.read(file1); } catch (IOException e) { document = null; logger.error(\"文件转换出错：\"+e); } catch (DocumentException e) { document = null; logger.error(\"读取文件出错：\"+e); } return document; } public static void main(String[] args){ //创建xml Document document = DocumentHelper.createDocument(); //创建节点 Element elements = document.addElement(\"list\"); for (int i = 0; i &lt; 1; i++) { Element ele = elements.addElement(\"CustomsDeclareBill\"); ele.addAttribute(\"id\", \"6\"); Element nameEle = ele.addElement(\"提运单号\"); nameEle.setText(\"55555\"); OutputFormat format = OutputFormat.createPrettyPrint();//Format格式！！ format.setEncoding(\"UTF-8\"); XMLWriter writer = null; try { writer = new XMLWriter(format); } catch (UnsupportedEncodingException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } try { //讲xml文档输出到控制台上 writer.write(document); } catch (IOException e) { e.printStackTrace(); } } } public static String replaceNullString(String str){ if(str == null ){ return \"\"; }else if(str.equals(\"\")){ return \"\"; }else{ return str; } } } 最后导出个xml文件如图所示: 以上三种方法都是本人亲测并实现的功能，有什么问题欢迎留言询问~如果觉得此文对你有帮助的话，顶一下文哦~ 部分代码参考自http://www.cnblogs.com/zgqys1980/archive/2009/10/17/1585052.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SSM","slug":"SSM","permalink":"http://jiubanmoli.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://jiubanmoli.github.io/tags/SSM/"}]},{"title":"MyBatis中动态SQL语句完成多条件查询","slug":"mybatis-three","date":"2019-01-20T08:25:16.320Z","updated":"2022-01-04T13:58:00.108Z","comments":true,"path":"2019/01/20/mybatis-three/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mybatis-three/","excerpt":"","text":"choose（when otherwise）相当于Java中的switch语句，通常when和otherwise一起使用。 where：简化SQL语句中的where条件。 set 解决SQL语句中跟新语句 我们课已通过几个例子来看一下这几个元素的运用场景： if: &lt;select id=\"queryEmp\" resultType=\"cn.test.entity.Emp\"> select * from emp where 1=1 &lt;if test=\"deptNo!=null\"> and deptno=#{deptNO} &lt;/if> &lt;if test=\"deptName!=null\"> and deptno=#{deptName} &lt;/if> &lt;/select> 注：&lt;if test=\"deptNo!=null\"&gt;中 的deptNo是指实体类中的属性或字段； choose：: &lt;select id=\"queryEmp\" resultType=\"cn.test.entity.Emp\"> select * from emp where 1=1 &lt;choose> &lt;when test=\"deptNo!=null\"> and deptno=#{deptNo} &lt;/when> &lt;when test=\"deptName!=null\"> and deptname=#{deptName} &lt;/when> &lt;otherwise> and personnum>#{personNum} &lt;/otherwise> &lt;/choose> &lt;/select> 注：上面也说了，choose相当于Java中的switch语句；当第一个when满足时；就只执行第一个when中的条件。当when中的条件都不满足时；就会执行默认的的；也就是otherwise中的语句。 where：: &lt;select id=\"queryEmp\" resultType=\"cn.test.entity.Emp\"> select * from emp &lt;where> &lt;if test=\"deptNo!=null\"> and deptno=#{deptNO} &lt;/if> &lt;if test=\"deptName!=null\"> and deptno=#{deptName} &lt;/if> &lt;/where> &lt;/select> 注： where下面第一个if语句中以and开头，也可以省略第一个and ，如果第一个if语句中有and；mybatis会将第一个and忽略。 set：: &lt;update id=\"updateEmp\" parameterType=\"cn.test.entity.Emp\" flushCache=\"true\"> update emp &lt;set> &lt;if test=\"empName!=null\">empname=#{empName},&lt;/if> &lt;if test=\"job!=null\">job=#{job}&lt;/if> &lt;/set> where empno=#{empNo} &lt;/update> in:: &lt;select id=\"dynamicForeachTest\" resultType=\"Blog\"> select * from t_blog where id in &lt;foreach collection=\"list\" index=\"index\" item=\"item\" open=\"(\" separator=\",\" close=\")\"> #{item} &lt;/foreach> &lt;/select> 测试代码: @Test public void dynamicForeachTest() { SqlSession session = Util.getSqlSessionFactory().openSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); List&lt;Integer> ids = new ArrayList&lt;Integer>(); ids.add(1); ids.add(3); ids.add(6); List&lt;Blog> blogs = blogMapper.dynamicForeachTest(ids); for (Blog blog : blogs){} System.out.println(blog); session.close(); } } 注： 在mybatis中的SQL语句结尾不能加“；”，这样会导致mybatis无法识别字符；导致SQL语句的语法错误；出现 java.sql.SQLSyntaxErrorException:ORA-00911: 无效字符的错误。的异常。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://jiubanmoli.github.io/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://jiubanmoli.github.io/tags/mybatis/"}]},{"title":"Java中Date与String的相互转换","slug":"DateToString","date":"2019-01-20T08:17:34.517Z","updated":"2022-01-04T13:57:59.992Z","comments":true,"path":"2019/01/20/datetostring/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/datetostring/","excerpt":"","text":"我们在注册网站的时候，往往需要填写个人信息，如姓名，年龄，出生日期等，在页面上的出生日期的值传递到后台的时候是一个字符串，而我们存入数据库的时候确需要一个日期类型，反过来，在页面上显示的时候，需要从数据库获取出生日期，此时该类型为日期类型，然后需要将该日期类型转为字符串显示在页面上，Java的API中为我们提供了日期与字符串相互转运的类DateForamt。DateForamt是一个抽象类，所以平时使用的是它的子类SimpleDateFormat。SimpleDateFormat有4个构造函数，最经常用到是第二个。 构造函数中pattern为时间模式，具体有什么模式，API中有说明，如下 1、日期转字符串（格式化） package com.test.dateFormat; import java.text.SimpleDateFormat; import java.util.Date; import org.junit.Test; public class Date2String { @Test public void test() { Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); System.out.println(sdf.format(date)); sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf.format(date)); sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); System.out.println(sdf.format(date)); } } 输出结果:1 2016-10-242 2016-10-24 21:59:063 2016年10月24日 21:59:06 2、字符串转日期（解析） package com.test.dateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import org.junit.Test; public class String2Date { @Test public void test() throws ParseException { String string = \"2016-10-24 21:59:06\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf.parse(string)); } } 输出结果Mon Oct 24 21:59:06 CST 2016 在字符串转日期操作时，需要注意给定的模式必须和给定的字符串格式匹配，否则会抛出java.text.ParseException异常，例如下面这个就是错误的，字符串中并没有给出时分秒，那么SimpleDateFormat当然无法给你凭空解析出时分秒的值来 package com.test.dateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import org.junit.Test; public class String2Date { @Test public void test() throws ParseException { String string = \"2016-10-24\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf.parse(string)); } } 不过，给定的模式比字符串少则可以 package com.test.dateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import org.junit.Test; public class String2Date { @Test public void test() throws ParseException { String string = \"2016-10-24 21:59:06\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); System.out.println(sdf.parse(string)); } } 输出结果:Mon Oct 24 00:00:00 CST 2016 可以看出时分秒都是0，没有被解析，这是可以的。 链接： https://www.cnblogs.com/huangminwen/p/5994846.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"Date","slug":"Date","permalink":"http://jiubanmoli.github.io/tags/Date/"},{"name":"String","slug":"String","permalink":"http://jiubanmoli.github.io/tags/String/"}]},{"title":"java中Integer转Float总结以及BigDecimal 转float","slug":"integerToFloat","date":"2019-01-20T08:13:43.288Z","updated":"2022-01-04T13:58:00.076Z","comments":true,"path":"2019/01/20/integertofloat/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/integertofloat/","excerpt":"","text":"一.先将Integer转化成int类型，在强制转float类型() 例: Integer str = new Integer(20); int i = str.intValue(); float rr = (float)i; 输出结果为:20.0 二.将Integer类型转成String类型,在转化成float类型 例: Integer str = 2056; String format = new BigDecimal(String.valueOf(str)).toString(); float rr = Float.valueOf(format); 输出结果为20.0 三.BigDecimal 转float 例: BigDecimal tt = new BigDecimal(50) ; float kk = tt.floatValue(); 输出结果:50.0 以上均本人亲自测试，如不符合，请仔细检查 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"Integer","slug":"Integer","permalink":"http://jiubanmoli.github.io/tags/Integer/"},{"name":"Float","slug":"Float","permalink":"http://jiubanmoli.github.io/tags/Float/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"http://jiubanmoli.github.io/tags/BigDecimal/"}]},{"title":"Statement cancelled due to timeout or client request","slug":"mysql-two","date":"2019-01-20T08:09:09.391Z","updated":"2022-01-04T13:58:00.114Z","comments":true,"path":"2019/01/20/mysql-two/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mysql-two/","excerpt":"","text":"Caused by: com.mysql.jdbc.exceptions.MySQLTimeoutException: Statement cancelled due to timeout or client request at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2303) at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2696) at com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:2105) at com.mysql.jdbc.PreparedStatement.executeUpdate(PreparedStatement.java:2398) at com.mysql.jdbc.PreparedStatement.executeUpdate(PreparedStatement.java:2316) at com.mysql.jdbc.PreparedStatement.executeUpdate(PreparedStatement.java:2301) at org.jboss.resource.adapter.jdbc.CachedPreparedStatement.executeUpdate(CachedPreparedStatement.java:95) at org.jboss.resource.adapter.jdbc.WrappedPreparedStatement.executeUpdate(WrappedPreparedStatement.java:251) 解决方法: 设置defaultStatementTimeout=”60”在sqlmap.xml中设置，表示60s &lt;settings cacheModelsEnabled=\"false\" enhancementEnabled=\"true\" lazyLoadingEnabled=\"false\" errorTracingEnabled=\"true\" maxRequests=\"32\" maxSessions=\"10\" maxTransactions=\"5\" useStatementNamespaces=\"true\" defaultStatementTimeout=\"60\" /&gt; 链接: http://blog.csdn.net/u014698348/article/details/53409786 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://jiubanmoli.github.io/categories/MYSQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://jiubanmoli.github.io/tags/mysql/"}]},{"title":"关于字符串重复调用转换的优化方法","slug":"StringtoConvert","date":"2019-01-20T08:06:03.295Z","updated":"2022-01-04T13:58:00.041Z","comments":true,"path":"2019/01/20/stringtoconvert/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/stringtoconvert/","excerpt":"","text":"我们通常如果数据库定义的是int类型，但是需求是页面显示的是字符串，如果是多个方法，就需要重复调用，所以为此，我们提供了枚举类型来优化， 例子如下: if(StringUtils.isNotBlank(singleCenter.getStatus())){ switch (singleCenter.getStatus()) { case \"0\": listStatus=\"已接单\"; break; case \"1\": listStatus=\"未处理\"; break; case \"2\": listStatus=\"已拒绝\"; break; case \"3\": listStatus=\"代接单\"; break; case \"4\": listStatus=\"代下单\"; break; } singleCenter.setStatus(listStatus); } 优化方法:定义一个枚举类:将你需要转换的字符串如下显示，然后调用下面的getTypeValue()方法，再在你需要转换的代码中调用该方法就OK了 public enum BusinessTypeEnum { //这里就是定义index对应的value TYPE_1(0,\"海运进口整箱\"),TYPE_2(1,\"海运进口拼箱\"),TYPE_3(2,\"海运出口整箱\"),TYPE_4(3,\"海运出口拼箱\"),TYPE_5(4,\"空运进口\") ,TYPE_6(5,\"空运出口\"),TYPE_7(6,\"集装箱出口\"),TYPE_8(7,\"集装箱进口\"),TYPE_9(8,\"多式联运\"),TYPE_10(9,\"集装箱\") ,TYPE_11(10,\"散货船\"),TYPE_12(11,\"干线运输\"),TYPE_13(12,\"零担运输\"),TYPE_14(13,\"仓储运输\"); private int index; private String value; private BusinessTypeEnum(int index,String value){ this.index = index; this.value = value; } public int getIndex() { return index; } public void setIndex(int index) { this.index = index; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } //主要通过这个方法来去value public static String getTypeValue(int index){ for(BusinessTypeEnum e : BusinessTypeEnum.values()){ if(e.getIndex() == index){ return e.getValue(); } } return \"\"; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"String字符串","slug":"String字符串","permalink":"http://jiubanmoli.github.io/tags/String字符串/"}]},{"title":"win10系统的mysql下载安装(详细内容)以及出现的一系列问题解决方案","slug":"mysql","date":"2019-01-20T07:59:06.279Z","updated":"2022-01-04T13:58:00.116Z","comments":true,"path":"2019/01/20/mysql/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/mysql/","excerpt":"","text":"1.解压文件 2.安装mysql 3.配置环境变量 鼠标单击我的电脑——&gt;属性——&gt;高级系统设置——&gt;环境变量 (1).添加用户变量 (2).设置系统变量 3.打开cmd，使用cmd管理员身份运行，输入命令行mysqld –initialize初始化data文件夹,成功之后，安装mysql服务,输入命令行mysql -install,成功之后，启动mysql服务, 4.输入net start mysql启动服务，启动成功之后输入 mysql –u root,运行mysql命令 5.mysql&gt;show databases; mysql&gt;use mysql; mysql&gt; UPDATE user SET authentication_string = PASSWORD(‘123456’) WHERE user = ‘root’; 查看修改的密码: select host,user,password from mysql.user;然后刷新，输入 mysql&gt;FLUSH PRIVILEGES;最后输入quit;退出, 6.测试重新登录停止服务:net stop mysql,重新启动,输入命令行mysql -u root -p,输入密码就OK了 7.关于安装出现的一系列问题及解决方案 (1) 安装初始化的时候没有data文件夹，这个问题我自己也尝试了很多，没用，最后自己选了一个较低的版本才可以，如果哪位解决了欢迎指导一下,我最后选的版本是mysql-5.5.44-winx64版本的 (2)ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO)，当你设置了密码之后，你不能使用mysql -u root登录，需要输入mysql -u root -p进行密码登录，如果密码忘记，需要在停止服务,具体详情可看这http://blog.csdn.net/u012903926/article/details/46405551 8.卸载重装mysql (1)bin/输入命令行mysqld -remove (2)彻底删除，打开注册表，win+r,打开regidet，删除以下注册表： HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Services/Eventlog/Applications/MySQL HKEY_LOCAL_MACHINE/SYSTEM/ControlSet002/Services/Eventlog/Applications/MySQL HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Eventlog/Applications/MySQL （在我的电脑里是没有这条信息的） (3) 网上的一些方法基本就是做到这一步就搞定了，然而我的却还是不行，索性在C盘中打开搜索‘mysql’相关字眼，居然还找到了，在这个路径下的： C:\\ProgramData\\MySQL 尝试着删除之后，安装成功。 结论就是：卸载东西一定要删除干净！ 另外，C:\\ProgramData下存储的是程序的数据，请不要随意删除这个文件夹下的文件。补充：刚试验了下，卸载mysql后，仅删除安装路径文件和ProgramData的mysql文件也可以安装成功了。 链接： https://www.cnblogs.com/honor-007/p/honor.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://jiubanmoli.github.io/categories/MYSQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://jiubanmoli.github.io/tags/mysql/"}]},{"title":"破解 Navicat Premium 12","slug":"navicat","date":"2019-01-20T07:51:38.614Z","updated":"2022-01-04T13:58:00.120Z","comments":true,"path":"2019/01/20/navicat/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/navicat/","excerpt":"","text":"1、软件下载 （1）Navicat官网：https://www.navicat.com/en/products （2）网盘下载：http://pan.baidu.com/s/1bpm2BjL 密码：mwmm （网盘版本：Navicat Premium 12.0.11，简体中文，64位） 2、语言设置：navicat 语言选择跟 软件的版本相关，也就说一个版本的软件仅适用于一种语言，所以选择合适的版本将直接关乎后期使用的“手感”在语言选择上 Navicat 官网的做法特别坑爹，在官网首页就要选择相应的语言，而不能够在具体的下载页选择相应的语言版本，如图： 3、版本选择：官网提供了多达6种数据库语言的版本选择，分别为 MySQL、Oracle、SQL Server、MariaDB、PostgreSQL 和 SQLite，你可以选择适合的版本下载，也可以使用涵盖6种语言的综合版本 Navicat Premium,这里当然是推荐使用：Navicat Premium 啦。。 4、破解 Navicat Premium 12 （1）破解补丁下载，网盘： 链接：https://pan.baidu.com/s/1mhLIjQ4 密码：avru 链接：https://pan.baidu.com/s/1c2eWtcW 密码：dtaf 或者针对网盘版本 Navicat Premium 12.0.11，简体中文，64位的： 链接：http://pan.baidu.com/s/1mh9AC7Q 密码：y52p （2）破解方法： 将解压出来的 version.dll 和 payload.bin 扔到软件安装根目录即可，具体细节嘛~ @jixun66：https://www.52pojie.cn/thread-618718-1-1.html （3）特别说明： 本方法实际上并没有真正意义上的添加注册码，而是在软件启动时引入注册验证之前添加访问拦截，实现了跳过注册验证而直接使用软件的方法，原则上与“破解”并无二致 链接： http://blog.csdn.net/MAOZEXIJR/article/details/77773860?locationNum=7&amp;fps=1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://jiubanmoli.github.io/categories/开发工具/"}],"tags":[{"name":"navicat","slug":"navicat","permalink":"http://jiubanmoli.github.io/tags/navicat/"}]},{"title":"Spring MVC之@RequestBody, @ResponseBody 详解","slug":"springmvc","date":"2019-01-20T07:32:30.144Z","updated":"2022-01-04T13:58:00.144Z","comments":true,"path":"2019/01/20/springmvc/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/springmvc/","excerpt":"","text":"之前练习springboot+mybatis实现Restful服务，给予HTTP/JSON格式传输，但是在新增的时候出现一个维妮塔，就是我传的参数到数据库为Null值，我仔细检查了个个层的代码，后面发现实在Controller中将@Requestbody写成了@ResponseBody,因为我这里只需直接添加数据，使用postman工具进行测试，不需要返回值，所以导致出错，下面就说下这两者的区别吧。 简介：@RequestBody: 作用： 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。 使用时机： A) GET、POST方式提时， 根据request header Content-Type的值来判断: application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）； multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）； 其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）； B) PUT方式提交时， 根据request header Content-Type的值来判断: application/x-www-form-urlencoded， 必须； multipart/form-data, 不能处理； 其他格式， 必须； 说明：request的body部分的数据编码格式由header部分的Content-Type指定； @ResponseBody:作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； HttpMessageConverter: * Strategy interface that specifies a converter that can convert from and to HTTP requests and responses. * * @author Arjen Poutsma * @author Juergen Hoeller * @since 3.0 */ public interface HttpMessageConverter&lt;T> { /** * Indicates whether the given class can be read by this converter. * @param clazz the class to test for readability * @param mediaType the media type to read, can be {@code null} if not specified. * Typically the value of a {@code Content-Type} header. * @return {@code true} if readable; {@code false} otherwise */ boolean canRead(Class&lt;?> clazz, MediaType mediaType); /** * Indicates whether the given class can be written by this converter. * @param clazz the class to test for writability * @param mediaType the media type to write, can be {@code null} if not specified. * Typically the value of an {@code Accept} header. * @return {@code true} if writable; {@code false} otherwise */ boolean canWrite(Class&lt;?> clazz, MediaType mediaType); /** * Return the list of {@link MediaType} objects supported by this converter. * @return the list of supported media types */ List&lt;MediaType> getSupportedMediaTypes(); /** * Read an object of the given type form the given input message, and returns it. * @param clazz the type of object to return. This type must have previously been passed to the * {@link #canRead canRead} method of this interface, which must have returned {@code true}. * @param inputMessage the HTTP input message to read from * @return the converted object * @throws IOException in case of I/O errors * @throws HttpMessageNotReadableException in case of conversion errors */ T read(Class&lt;? extends T> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException; /** * Write an given object to the given output message. * @param t the object to write to the output message. The type of this object must have previously been * passed to the {@link #canWrite canWrite} method of this interface, which must have returned {@code true}. * @param contentType the content type to use when writing. May be {@code null} to indicate that the * default content type of the converter must be used. If not {@code null}, this media type must have * previously been passed to the {@link #canWrite canWrite} method of this interface, which must have * returned {@code true}. * @param outputMessage the message to write to * @throws IOException in case of I/O errors * @throws HttpMessageNotWritableException in case of conversion errors */ void write(T t, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException; } 该接口定义了四个方法，分别是读取数据时的 canRead(), read() 和 写入数据时的canWrite(), write()方法。 在使用 &lt;mvc:annotation-driven /&gt;标签配置时，默认配置了RequestMappingHandlerAdapter（注意是RequestMappingHandlerAdapter不是AnnotationMethodHandlerAdapter,详情查看Spring ByteArrayHttpMessageConverter converts byte arrays. StringHttpMessageConverter converts strings. ResourceHttpMessageConverter converts to/from org.springframework.core.io.Resource for all media types. SourceHttpMessageConverter converts to/from a javax.xml.transform.Source. FormHttpMessageConverter converts form data to/from a MultiValueMap&lt;String, String&gt;. Jaxb2RootElementHttpMessageConverter converts Java objects to/from XML — added if JAXB2 is present on the classpath. MappingJacksonHttpMessageConverter converts to/from JSON — added if Jackson is present on the classpath. AtomFeedHttpMessageConverter converts Atom feeds — added if Rome is present on the classpath. RssChannelHttpMessageConverter converts RSS feeds — added if Rome is present on the classpath. ByteArrayHttpMessageConverter: 负责读取二进制格式的数据和写出二进制格式的数据； StringHttpMessageConverter： 负责读取字符串格式的数据和写出二进制格式的数据； ResourceHttpMessageConverter：负责读取资源文件和写出资源文件数据； FormHttpMessageConverter： 负责读取form提交的数据（能读取的数据格式为 application/x-www-form-urlencoded，不能读取multipart/form-data格式数据）；负责写入application/x-www-from-urlencoded和multipart/form-data格式的数据； MappingJacksonHttpMessageConverter: 负责读取和写入json格式的数据； SouceHttpMessageConverter：负责读取和写入 xml 中javax.xml.transform.Source定义的数据； Jaxb2RootElementHttpMessageConverter: 负责读取和写入xml 标签格式的数据； AtomFeedHttpMessageConverter: 负责读取和写入Atom格式的数据； RssChannelHttpMessageConverter: 负责读取和写入RSS格式的数据； 当使用@RequestBody和@ResponseBody注解时，RequestMappingHandlerAdapter就使用它们来进行读取或者写入相应格式的数据。 补充：MappingJacksonHttpMessageConverter 调用了 objectMapper.writeValue(OutputStream stream, Object)方法，使用@ResponseBody注解返回的对象就传入Object参数内。若返回的对象为已经格式化好的json串时，不使用@RequestBody注解，而应该这样处理：1、response.setContentType(“application/json; charset=UTF-8”);2、response.getWriter().print(jsonStr);直接输出到body区，然后的视图为void。 链接: http://blog.csdn.net/kobejayandy/article/details/12690555 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://jiubanmoli.github.io/categories/SpringMVC/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jiubanmoli.github.io/tags/Web/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://jiubanmoli.github.io/tags/SpringMVC/"}]},{"title":"转载:关于对REST的基本认识和理解","slug":"rest","date":"2019-01-20T06:58:04.437Z","updated":"2022-01-04T13:58:00.122Z","comments":true,"path":"2019/01/20/rest/","link":"","permalink":"http://jiubanmoli.github.io/2019/01/20/rest/","excerpt":"","text":"让努力成为一种习惯。 1.什么是 REST?REST 是属于 WEB 自身的一种架构风格，是在 HTTP 1.1 规范下实现的。Representational State Transfer 全称翻译为表现层状态转化。Resource：资源。比如 newsfeed；Representational：表现形式，比如用JSON，富文本等；State Transfer：状态变化。通过HTTP 动作实现。REST是所有Web应用都应该遵守的架构设计指导原则。当然，REST并不是法律，违反了REST的指导原则，仍然能够实现应用的功能。但是违反了REST的指导原则，会付出很多代价，特别是对于大流量的网站而言。 2.REST架构风格最重要的架构约束有6个： 客户-服务器（Client-Server）: 通信只能由客户端单方面发起，表现为请求-响应的形式。 无状态（Stateless）: 通信的会话状态（Session State）应该全部由客户端负责维护。 缓存（Cache）: 响应内容可以在通信链的某处被缓存，以改善网络效率。 统一接口（Uniform Interface） 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性。 分层系统（Layered System） 通过限制组件的行为（即，每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 按需代码（Code-On-Demand，可选） 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 3.要深入理解REST，需要理解REST的五个关键词：1.资源（Resource）2.资源的表述（Representation）3.状态转移（State Transfer）4.统一接口（Uniform Interface）5.超文本驱动（Hypertext Driven）6.什么是资源？:资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。 什么是资源的表述？ 资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 什么是状态转移？ 状态转移（state transfer）与状态机中的状态迁移（state transition）的含义是不同的。状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。 什么是统一接口？ REST要求，必须通过统一的接口来对资源执行各种操作。对于每个资源只能执行一组有限的操作。以HTTP/1.1协议为例，HTTP/1.1协议定义了一个操作资源的统一接口，主要包括以下内容： 7个HTTP方法：GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS HTTP头信息（可自定义） HTTP响应状态代码（可自定义） 一套标准的内容协商机制 一套标准的缓存机制 一套标准的客户端身份认证机制 REST还要求，对于资源执行的操作，其操作语义必须由HTTP消息体之前的部分完全表达，不能将操作语义封装在HTTP消息体内部。这样做是为了提高交互的可见性，以便于通信链的中间组件实现缓存、安全审计等等功能。 什么是超文本驱动？ “超文本驱动”又名“将超媒体作为应用状态的引擎”（Hypermedia As The Engine Of Application State，来自Fielding博士论文中的一句话，缩写为HATEOAS）。将Web应用看作是一个由很多状态（应用状态）组成的有限状态机。资源之间通过超链接相互关联，超链接既代表资源之间的关系，也代表可执行的状态迁移。在超媒体之中不仅仅包含数据，还包含了状态迁移的语义。以超媒体作为引擎，驱动Web应用的状态迁移。通过超媒体暴露出服务器所提供的资源，服务器提供了哪些资源是在运行时通过解析超媒体发现的，而不是事先定义的。从面向服务的角度看，超媒体定义了服务器所提供服务的协议。客户端应该依赖的是超媒体的状态迁移语义，而不应该对于是否存在某个URI或URI的某种特殊构造方式作出假设。一切都有可能变化，只有超媒体的状态迁移语义能够长期保持稳定。 4.从架构风格的抽象高度来看，常见的分布式应用架构风格有三种： 分布式对象（Distributed Objects，简称DO） 架构实例有CORBA/RMI/EJB/DCOM/.NET Remoting等等 远程过程调用（Remote Procedure Call，简称RPC） 架构实例有SOAP/XML-RPC/Hessian/Flash AMF/DWR等等 分布式对象（Distributed Objects，简称DO） 架构实例有HTTP/WebDAV DO和RPC这两种架构风格在企业应用中非常普遍，而REST则是Web应用的架构风格，它们之间有非常大的差别。 REST与DO的差别在于： REST支持抽象（即建模）的工具是资源，DO支持抽象的工具是对象。在不同的编程语言中，对象的定义有很大差别，所以DO风格的架构通常都是与某种编程语言绑定的。跨语言交互即使能实现，实现起来也会非常复杂。而REST中的资源，则完全中立于开发平台和编程语言，可以使用任何编程语言来实现。 DO中没有统一接口的概念。不同的API，接口设计风格可以完全不同。DO也不支持操作语义对于中间组件的可见性。 DO中没有使用超文本，响应的内容中只包含对象本身。REST使用了超文本，可以实现更大粒度的交互，交互的效率比DO更高。 REST支持数据流和管道，DO不支持数据流和管道。 DO风格通常会带来客户端与服务器端的紧耦合。在三种架构风格之中，DO风格的耦合度是最大的，而REST的风格耦合度是最小的。REST松耦合的源泉来自于统一接口+超文本驱动。 REST与RPC的差别在于： REST支持抽象的工具是资源，RPC支持抽象的工具是过程。REST风格的架构建模是以名词为核心的，RPC风格的架构建模是以动词为核心的。简单类比一下，REST是面向对象编程，RPC则是面向过程编程。 RPC中没有统一接口的概念。不同的API，接口设计风格可以完全不同。RPC也不支持操作语义对于中间组件的可见性。 RPC中没有使用超文本，响应的内容中只包含消息本身。REST使用了超文本，可以实现更大粒度的交互，交互的效率比RPC更高。 REST支持数据流和管道，RPC不支持数据流和管道。 因为使用了平台中立的消息，RPC风格的耦合度比DO风格要小一些，但是RPC风格也常常会带来客户端与服务器端的紧耦合。支持统一接口+超文本驱动的REST风格，可以达到最小的耦合度。 比较了三种架构风格之间的差别之后，从面向实用的角度来看，REST架构风格可以为Web开发者带来三方面的利益: 简单性 采用REST架构风格，对于开发、测试、运维人员来说，都会更简单。可以充分利用大量HTTP服务器端和客户端开发库、Web功能测试/性能测试工具、HTTP缓存、HTTP代理服务器、防火墙。这些开发库和基础设施早已成为了日常用品，不需要什么火箭科技（例如神奇昂贵的应用服务器、中间件）就能解决大多数可伸缩性方面的问题。 可伸缩性 充分利用好通信链各个位置的HTTP缓存组件，可以带来更好的可伸缩性。其实很多时候，在Web前端做性能优化，产生的效果不亚于仅仅在服务器端做性能优化，但是HTTP协议层面的缓存常常被一些资深的架构师完全忽略掉。 松耦合 统一接口+超文本驱动，带来了最大限度的松耦合。允许服务器端和客户端程序在很大范围内，相对独立地进化。对于设计面向企业内网的API来说，松耦合并不是一个很重要的设计关注点。但是对于设计面向互联网的API来说，松耦合变成了一个必选项，不仅在设计时应该关注，而且应该放在最优先位置。 链接：http://www.infoq.com/cn/articles/understanding-restful-style document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://jiubanmoli.github.io/categories/Java-Web/"}],"tags":[{"name":"REST","slug":"REST","permalink":"http://jiubanmoli.github.io/tags/REST/"},{"name":"Web","slug":"Web","permalink":"http://jiubanmoli.github.io/tags/Web/"}]},{"title":"Idea配置tomcat运行成功后报404","slug":"idea-tomcat","date":"2018-08-16T07:08:23.236Z","updated":"2022-01-04T13:58:00.072Z","comments":true,"path":"2018/08/16/idea-tomcat/","link":"","permalink":"http://jiubanmoli.github.io/2018/08/16/idea-tomcat/","excerpt":"","text":"解决办法： 1.将Tomcat的首页的工程部署到Tomcat服务器上，部署步骤如下： 选择菜单栏“Run–&gt;Edit Configuration…–&gt;Deployment”,选择右上角绿色“+”，选择“External Source…”，将Apache-tomcat的webapps目录下的ROOT文件夹选中，点击OK，及完成Tomcat的首页的工程的部署。选择ROOT文件后右侧Application Context 可不填写，默认即可。 选择菜单栏“Run–&gt;Edit Configuration…–&gt;Deployment”,选择右上角绿色“+”，选择“Artifact…”，选择exploded项，点击OK。 右侧Application Context 可填写为访问URL名称。 再次运行项目，项目成功运行啦。 这次再访问http://localhost:8080/，熟悉的猫咪出来了。 2.将tomcat中的catalina.bat打开，如果之前设置了set JAVA_POST,去掉，就OK了，这里的原因是因为Idea会给tomcat配置参数，如果之前有，就会覆盖IDea的，导致冲突 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Idea","slug":"Idea","permalink":"http://jiubanmoli.github.io/categories/Idea/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://jiubanmoli.github.io/tags/idea/"},{"name":"tomcat","slug":"tomcat","permalink":"http://jiubanmoli.github.io/tags/tomcat/"}]},{"title":"Mybatis自动生成插件对数据库类型为text的处理","slug":"mybatis-generator","date":"2018-08-16T06:26:12.079Z","updated":"2022-01-04T13:58:00.096Z","comments":true,"path":"2018/08/16/mybatis-generator/","link":"","permalink":"http://jiubanmoli.github.io/2018/08/16/mybatis-generator/","excerpt":"","text":"如果数据库中的字段为text或者blob这种大文本类型，在使用MybatisGenerator工具自动生成代码的时候会将其进行特殊处理（一个新的sql片段），结果会导致无法对该字段的值进行操作。 解决方式： 方法1：改java代码，如下图所示，使用自动生成的对应方法。 方法2：修改generatorConfig.xml配置文件，其中column为你需要覆盖的数据库字段 &lt;table tableName=\"mock_config\" domainObjectName=\"MockConfig\"> &lt;columnOverride column=\"backon_result\" jdbcType=\"VARCHAR\" /> &lt;/table> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程","slug":"programming","permalink":"http://jiubanmoli.github.io/categories/programming/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://jiubanmoli.github.io/tags/mybatis/"}]},{"title":"关于mybatis中resultType返回null的问题","slug":"mybatis-two","date":"2018-08-16T06:23:16.212Z","updated":"2022-01-04T13:58:00.104Z","comments":true,"path":"2018/08/16/mybatis-two/","link":"","permalink":"http://jiubanmoli.github.io/2018/08/16/mybatis-two/","excerpt":"","text":"1.resultType 就是返回的类型 2.resultMap 返回的是一个结果集，这个结果集一般是用过resultMap节点来配置的，相应的type一般是一个Model。而resultType则就是类型，包括了，int,sring,以及类似model这样的Object类型。 3.需要注意的是如果把返回resultType结果写成resultMap节点配置出来的类似 ModelMap这样的结果集，就会在BuildSession的时候抛空指针。 而IBATIS只是会提示NullPointer，必须加到源代码调试放能看到会提示ClassNotFound，ModelMap找不到。 所以，如果是创建SqlSession的时候出错，提示空指针，那么错误的几种可能就是配置文件的错误1.SalMapConfig 里面文件路径,文件名2.Model.xml 里面resultMap映射的时候名字写错。3.Model.xml 里面的参数错误，例如返回ModelMap写成了model，返回的resultType写成了ModelMap 4.其余的可能都是拼写的错误。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://jiubanmoli.github.io/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://jiubanmoli.github.io/tags/mybatis/"}]},{"title":"idea2017.3创建springboot项目报Unsupported major.minor version 52.0的解决方案","slug":"springboot","date":"2018-08-16T06:16:50.662Z","updated":"2022-01-04T13:58:00.133Z","comments":true,"path":"2018/08/16/springboot/","link":"","permalink":"http://jiubanmoli.github.io/2018/08/16/springboot/","excerpt":"","text":"如果你的jdk是1.7并且在搭建springboot项目时报如上错，请按此步骤，已测试并通过 解决方法步骤： 将java版本改为1.7 将springboot的版本改为1.4.7，默认的是2.0.1，这里为啥要改成1.4.7因为2.0.1内置的JDK是1.8 点击file-settings-java compiler选择1.7 file-project structure选择Project的JDK版本，Modules的JDK版本，以及SDK版本 5.再重新运行DemoApplication就OK了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Idea","slug":"Idea","permalink":"http://jiubanmoli.github.io/categories/Idea/"}],"tags":[{"name":"Idea","slug":"Idea","permalink":"http://jiubanmoli.github.io/tags/Idea/"},{"name":"springBoot","slug":"springBoot","permalink":"http://jiubanmoli.github.io/tags/springBoot/"}]},{"title":"张嘉倪：我要嫁的不是王子，而是永远拿我当小公主的人","slug":"zhangjiani","date":"2018-07-21T03:44:54.967Z","updated":"2022-01-04T13:58:00.157Z","comments":true,"path":"2018/07/21/zhangjiani/","link":"","permalink":"http://jiubanmoli.github.io/2018/07/21/zhangjiani/","excerpt":"","text":"1. 近日，张嘉倪因出演电视剧《温暖的弦》而再次大火，老公买超也上了微博热搜。 据悉，张嘉倪老公不仅是一位超级富二代，还有自己独立的事业——一家大型婚礼及活动策划公司执行董事，跟国民老公王思聪是一个圈子的。188cm的身高，颜值爆表，名副其实的高富帅！ 当年张嘉倪参加一个朋友的婚礼，那次婚礼的策划人正是买超，买超对张嘉倪一见钟情，随后便对其展开了热烈的追求，张嘉倪也拒绝过买超两次，不过最终还是被买超的执着打动了。 在张嘉倪27岁生日当天买超求婚成功。他是很多女生心目中的白马王子，可是张嘉倪却说：我要嫁的不是王子，而是永远拿我当小公主的人。 两人登记结婚的日子是5月27日，那天是买超的生日，也是取了5.27的谐音“我爱妻”。 三年过去了，如今两人有了一个2岁的可爱儿子，张嘉倪又怀了二胎，生活幸福甜蜜。 生活中的买超还是个十足的奶爸， 微博里除了篮球就是老婆和孩子，张嘉倪的这份幸福让网友看在眼里，不禁感叹：紫菱终于遇到了现实版的费云帆。 婚姻幸福的秘诀：不管他是不是王子，但一定要把你当成公主来宠。 2. 前几天哈里王子大婚的消息又在朋友圈刷屏了。 这位英国王位第五顺位继承人，迎娶的是美国女演员梅根。 梅根出身贫民，母亲是美国黑人，父亲是荷兰裔的爱尔兰人。今年37岁，比哈里王子大3岁，离过婚还带着一个娃。 哈里王子对梅根赤诚一片，顶着全世界的反对和王室的压力也照样把她娶进家门，而且还拒签婚前协议。 这份协议关乎的可不是几套房子，几辆车子，这份协议涉及的资产约为3000万英镑，折合成人民币大约3亿元。 拒签这份协议也就意味着，婚后如果面临离婚，梅根就要分走他1.5亿元的财产。 据他的一位朋友透露，“他确定他的婚姻将是一个持久的婚姻，所以他不需要签署任何东西。” 真正爱你的男人，不会在乎你们身份地位是否悬殊，即使他是王子，你是灰姑娘，他依然会奋力为你披荆斩棘。 不是公主没关系，你的王子会把你宠成公主。 3. 同样是嫁人，我的朋友小暖就没那么幸运了。 小暖和老公李维是大学同学，两人从大二开始交往。 小暖父母经商多年，家境殷实，她一直是父母捧在手心里的宝，从小没受过苦，也不知道苦日子是什么体验。 李维家在农村，父亲是镇上小学的老师，母亲没工作。 大学毕业以后，小暖家托关系帮李维在这个城市找到了一份体面的工作，转眼二人开始谈婚论嫁。 因为考虑到李维的家庭条件，小暖家主动承担起了买房和装修的花费，没让李维家出一分钱。 婚后小暖从李维老家的亲戚处听说，李维的妈妈到处和人炫耀，说自己儿子有本事，娶了个倒贴钱的老婆。小暖听后很恼火。 小暖怀孕后，李维想把妈妈从老家叫来照顾小暖，小暖并不想和婆婆生活在一起，也不需要她的照顾，就拒绝了。 没想到婆婆竟然不请自来了，而且处处看小暖不顺眼。 “我们那时候第二天生孩子，头一天还要在地里干活，哪像现在的人这么娇气，怀个娃就不得了嘞。” 诸如此类的话，婆婆整天挂在嘴边，小暖每天都在生闷气。 婆婆来之前李维对小暖还算不错，婆婆来了以后，他非但不照顾怀孕的小暖，反而把小暖指使地团团转，一会让她做这个，一会让她做那个，稍微磨蹭了一会，他就会抱怨，“你这怀个孕怎么跟生活不能自理了似的。” 婆婆接茬：“男人要是什么都能做，还娶婆娘做啥子？” 一次，小暖实在受不了他们娘俩合起伙来欺负她，和老公大吵起来，婆婆还在身边帮腔，“不要以为你是城里人就瞧不起我们农村人，嫁到我们家就得供我们使唤，有本事不要托生成女人。” 小暖气得拿起桌上的烟灰缸准备朝老公扔过去，婆婆眼疾手快，为了保护儿子推了小暖一把，小暖的肚子狠狠地撞在了桌角上，流产了。 孩子没了，小暖的心也死了，两人离婚了。 不爱你的男人，即使他不是王子是乞丐，他仍然会把你当成女仆，对你颐指气使。 他不会感激你不嫌弃他的条件嫁给他，反而会认为你没本事找到更好的。 4. 真正把你当成公主一样宠爱的男人，不会随便对你发脾气，不会事事与你计较，因为他舍不得。 车厘子在《做一个被时光宠爱的女子》一书中说： 一个真正爱你的男人，不会舍得让自己心爱的女人受一点点委屈，更不忍眼睁睁看着自己的爱人降低姿态，卑躬屈膝。 女人一定要嫁给那个宠溺自己的男人，如果你爱他胜过他爱你，那么在你们两个人的相处过程中，你注定永远对他高山仰止。 一辈子很长，没必要委屈自己。 把你当小公主的男人，不会无缘无故玩消失，无论再忙他都会记挂着你，即使他忙到没有时间来见你，他也会打个电话给你，告诉你他想你。 把你当小公主的男人，不会舍不得给你花钱，他会感激你赋予他为你花钱的资格。他想把所有你喜欢的东西统统买给你，因为他想让你知道，钱很重要，但是你比钱更重要。 把你当小公主的男人，不会在你和他父母起争执的时候，毫无原则地和父母站成一队攻击你。更不会说老婆可以换，父母不能换那种混账话。 把你当小公主的男人，不会对你们的关系遮遮掩掩，他会努力在你身上打造他的标志，恨不得昭告天下，你是他的。 把你当小公主的男人，永远不会嫌你麻烦，你的事他会比自己的事更加尽心尽力；永远不会嫌你唠叨，他会真正领会你对他的爱，你对他的好。 把你当小公主的男人，眼里只有你，再盛不下别的女人。你占据了他全部的心理空间，影响了他的审美标准。 女人，永远不要轻视自己，哪怕你的情况再遭，也终会有那么一个人在不远处等着你，给你岁月静好，给你现世安稳。 相信我，你配得上世间所有的美好。 作者：匹诺曹JS链接：https://www.jianshu.com/p/f2fe6fe41128來源：简书 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"life","permalink":"http://jiubanmoli.github.io/categories/life/"}],"tags":[{"name":"人生感悟","slug":"人生感悟","permalink":"http://jiubanmoli.github.io/tags/人生感悟/"},{"name":"明星","slug":"明星","permalink":"http://jiubanmoli.github.io/tags/明星/"}]},{"title":"你所谓的努力，只不过是其他人的日常","slug":"work","date":"2018-07-21T03:19:27.881Z","updated":"2022-01-04T13:58:00.155Z","comments":true,"path":"2018/07/21/work/","link":"","permalink":"http://jiubanmoli.github.io/2018/07/21/work/","excerpt":"","text":"努力它不说谎，任何间歇性的踌躇满志只能欺骗自己。你以为自己在拼命，但那只是别人的起跑线。 经常有人问我，为什么我这么努力，还不见一点效果？ 想要纤瘦的身材，在暴饮暴食了一周之后，饿了两天，只喝水不进食，前胸贴后背地抱怨： 为什么我这么努力减肥，只瘦了两斤？ 想要学好英语，说一口流利外语，拿起书本没日没夜得背了几页单词，气急败坏地质问： 为什么我这么努力学英语，一点效果都没有？ 努力它不说谎，任何间歇性的踌躇满志只能欺骗自己。你以为自己在拼命，但那只是别人的起跑线。 努力，它不说谎。努力了还不行，说明还不够。 前段时间看《偶像练习生》，除了小奶狗们的高颜值大长腿，更吸引我的是里面居然还有很燃很燃的点，有几次看得我这个老阿姨热泪盈眶。 关于梦想，关于拼搏，关于努力。 印象最深刻的是有一次岳岳问张艺兴：努力了也没有出现很好的结果，觉得很迷茫，该怎么办？ 张PD回答： ** 你得问问自己，这个努力刻苦是从什么时候开始。如果是从这个节目开始，那当然了，别人都是几年几年地练。台上一分钟，台下十年功。 努力，它不说谎。努力了还不行，说明还不够。** 努力和天赋，是通往成功之路的两大法宝。没有天赋，你只能拼命。 有句话说，以大多数人的努力程度之低，根本轮不到拼天赋。 但你不得不承认，就是有人天生公主命，有着姣好的面容，优渥的家境，而你只是一个外表普通，家境普通的灰姑娘。 生命本来就是不公平的，但生活是公平的。你付出多少，它回馈你多少。 天生技不如人就要选择成为一条咸鱼，永远不翻身吗？ 当然不。上天没有给你公主命，是为了让你做自己的女王。 最近很火的《创造101》里，我最喜欢的不是那些凭借与生俱来的美丽就收获万千粉丝的A班女生，而是那些资质平平，却永远不服输，赤手空拳地去battle的F班女孩子。 几乎不睡觉，一直练习舞蹈，额外练习时间高达77小时40分钟，相当于把主题曲反复练习了450次。 努力和天赋，是通往成功之路的两大法宝。没有天赋，你只能拼命。 四 努力，它不说谎。 每个人都想在生活中找到捷径，但成功的路就是很远很远。即便如此，你所做的努力，迈出的每一步，都不会白费。 觉得努力了没有效果，要放弃的时候问问自己，是不是真的竭尽全力了。放弃很简单，但坚持下去一定很酷。 我很喜欢杰克.伦敦的一首诗： 我宁愿是燃烧后的灰烬，也不愿做匍匐地上的灰尘。我宁愿我的星火在耀目的火光中燃尽，也不愿任其干腐窒息。我宁愿做一闪而过的流星，每一个原子都壮丽地发光，也不愿做永恒沉睡的行星。人的生命是去生活，而不是仅仅存在着。 所有，先别管结果，就这么一直努力下去吧。 努力，它不说谎。 作者：Judy姐姐啊链接：https://www.jianshu.com/p/d45a04d1245c來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"life","permalink":"http://jiubanmoli.github.io/categories/life/"}],"tags":[{"name":"人生感悟","slug":"人生感悟","permalink":"http://jiubanmoli.github.io/tags/人生感悟/"}]},{"title":"喜欢的人在一起久了，会长得很像","slug":"like","date":"2018-07-21T03:07:32.420Z","updated":"2022-01-04T13:58:00.090Z","comments":true,"path":"2018/07/21/like/","link":"","permalink":"http://jiubanmoli.github.io/2018/07/21/like/","excerpt":"","text":"1 正在电脑前码字，男朋友突然惊诧出一声“卧槽！”我忙转身，“怎么了？” 男朋友望着我说：“我刚翻自己的照片，发觉跟你长的神似，简直就是男版的你！”我满腹狐疑，要过手机进行验证。真的，我们在眼神、表情上有着七分的相似，简直不可置信。 经男友一说，我才想起闺蜜平时也说我跟男友相像；记起平时跟男友合照，我们也会摆出相同的姿势、十分默契…… 原来，跟喜欢的人相处久了，真的会长得相像。 2 男朋友曾对我说过，“因为我，他才更珍视自己，想变得更好！”我起初认为这有点说不通，人不应该是为了自己才要变得优秀的嘛？因为别人的说法太牵强了吧。 一次，男友坐对面目不转睛地盯着我，那种感觉特别美好、似曾相识，但又说不出具体在哪见过，总之就是会让你特别有安全感。后来，我发现自己也经常会这样，男友看书时，自己会目不转睛盯着他，就想陪着他、欣赏他。因此常被他说“小傻子”。 我后来慢慢明白男友那句话里的深刻含义： 那个喜欢你的人，你会从他的眼睛和表情里看到他对你的欣赏，而在他眼里你的那些优点和魅力，也许是你自己从未关注过的。那个真心喜欢你并懂得欣赏你的人，就像一面你的专属镜子，照出你潜质里的特点，所以你才从他的眼睛里读到触动的感觉，很真实。 平凡普通的日子里，日常的细节中，互相喜欢的人会因为一个眼神就读懂对方的意思。会因为对方冲你微笑，你也跟着微笑。不知不觉中你发现，你们的表情和眼神，竟是如此相像。 3 曾经一档火爆的亲子节目《爸爸去哪儿》中，每次看到田亮一家同框，让人都忍不住要惊叹“这一家人是复制粘贴出来的吧！” 孩子与父母相似可以从遗传角度解释，但绝大多数夫妻二人却是没有亲缘关系的个体，他们之间的这种“夫妻相”的产生太神秘了。 命理学和面相学上说，命理结构相似的“同构”男女容易结为夫妇，而命理结构相似的人气质相貌本就是相似的。 照此看来，一见钟情、臭味相投的说法不无道理！ 心理学家们研究“夫妻相”问题时提出了“选择观”的说法。 我们择偶时，“相似性”是个体择偶偏好的重要影响因素，不可否认人会被与自身相似的人吸引 。心理学家们在研究中还发现，虽然人们容易对外表吸引力高的异性产生好感，但在实际结婚伴侣选择中，会更倾向选择外貌上相似的另一半成为伴侣。 进化心理学认为，使基因不断地传递是人类生存的本能，是进化的根源。基因相似理论（Genetic similarity theory）提出解释说，特征相似的背后是基因上的相似，而特征相似的两性结合则能形成更复杂、稳定、适应性高的机制，让基因更稳定、更好地传递下去。 因此，我们总强调“喜欢一个人，始于颜值，陷于才华，终于人品”，实际上是偏向于选择与自己外貌、性格、生活习性、价值观等都相似的另一半。 所谓跟三观相近的人结合才能长久，大概就是这个道理吧！ 4 很多伴侣在一开始其实并不相像，而是在一起生活久了之后才慢慢开始长得相像的。心理学家们又用“趋同观”和“情绪体验理论”解释了这一情况。 “趋同观”认为“夫妻相”可能是夫妻二人生活在相同的气候环境之中，有着同样的饮食习惯和生活习性所造成的。 密歇根大学在1987年就让学生们对众多夫妻的照片进行相似性评分，这些照片里包括了6对新婚夫妻和6对结婚25年以上的夫妻，结果发现人们认为结婚25年以上的夫妻面孔上更加相似。 此外，“情绪体验理论”的解释似乎更能形象地解释这一现象。 “情绪体验理论（a theory of emotional efference）”认为人们的情绪体验会导致血管变化，血管变化会部分地调节面部肌肉，面部肌肉组织的习惯性使用又可能永久地影响面部特征。 其实就像是那个和你在一起的人，你们在一起久了，你喜欢什么不喜欢什么他都知道，你是什么模样，他就学着什么模样，最后才长得相像。 其实我更觉得， 相爱的人之所以越来越相像，除了环境和生物基因本能的因素外，更重要的是我们都把对方当成了生命中最重要的人之一。 因为在乎，所以愿意去观察你的情绪，读出你情绪里的信息，然后切换到能让你感到舒服的方式。 因为你很重要，所以愿意和你在一个模式中生活生长:一起哭，一起笑，一起抓紧不放手……到最后，你变成了他，他变成了你，因为有对方的存在，我们才真切地感受到自己变得更加完整。 所以，我们一开始就应当选择那个和自己三观相近，并且欣赏我们的人，不为了将就而草率抉择。同时，每个已得偿所愿的人，都应当珍惜来之不易的缘分，互相给予爱与包容，相爱相融。 作者：一枝丘链接：https://www.jianshu.com/p/4839fca82e95來源：简书 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"life","permalink":"http://jiubanmoli.github.io/categories/life/"}],"tags":[{"name":"人生感悟","slug":"人生感悟","permalink":"http://jiubanmoli.github.io/tags/人生感悟/"}]},{"title":"你赚多少钱，决定了别人对你父母的态度","slug":"life","date":"2018-06-28T12:30:01.376Z","updated":"2022-01-04T13:58:00.088Z","comments":true,"path":"2018/06/28/life/","link":"","permalink":"http://jiubanmoli.github.io/2018/06/28/life/","excerpt":"","text":"01 你赚多少钱，决定了父母朋友对他们的态度 上周，我回老家看望父母。 恰好，我爸一个哥们的女儿要结婚了，他和其他哥们正一边喝茶一边商量随多少份子钱。 我爸随口对我说：“到时候人家婚礼，你也去吧。” 我正要说话，席间的一个叔叔突然笑了笑说：“你去了只会觉得惭愧吧？” 言下之意，人家很优秀，我去了只会觉得自己丢脸。 那个要结婚的姐姐，对我来说一直是“别人家的孩子”，国内最好的财经院校保送硕士，毕业没几年，已年薪六十万，在北京买了自己的小房子。 而我，在某二线城市国企，领着一份不咸不淡的死工资，毕业头两年差点养不活自己。 这样的差别，对比之下自然让人耻笑。 过了一会儿，那个叔叔又说：“你现在工资有六千了吗？总不能连人家的十分之一都不到吧？” 我轻笑，我那儿比不上大城市，赚的少，每个月收入也就六千乘以二吧。 我爸本来低头不知道说什么，听到我说这话，仿佛脊梁也挺直了一些。 可能是我丢脸的程度没他想得那么严重吧，后来那个叔叔就没说什么了。 当我把这事告诉我的好朋友时，她说： 人家硕士你本科，人家29岁你25岁，再说北京工资跟你那能直接比吗？两者有可比性吗？这人到底会不会说话啊。 我说，他并不是不会说话，而是对我们家，他并不放在眼里，所以不在乎你的尊严。 而他说这些话，踩的并不是我。我一个后辈，他犯不上跟我比。 他踩的是我爸，通过我的不成功，来证明我爸的不成功而已。 我刚毕业时，工资很低，常常被他们问得很尴尬。 其实， 他们不是没听我爸说过我的情况，但就是喜欢当面问上这么一下，然后看着我窘迫和爸妈脸上无光的样子。 好在今年，我的经济状况比去年好多了，才有了些底气。 而那个很厉害的姐姐，不用别人问，她爸妈就把她的事迹传遍了整个朋友圈。别人都对他们家，推崇备至。 一起长大的哥们之间，都存在着这样微妙的捧高踩低，更不用说社会了。 长大后，你赚多少钱，决定了父母在朋友圈中被尊重的程度。 哪怕其他什么都好，你的不争气，也会成为别人戳你父母的软肋。 02 你赚多少钱，决定了亲戚对你父母的态度 我有个异性朋友，叫鹏程。 他们家小时候很穷，所以他爸希望他未来能像大鹏展翅，前程万里。 而鹏程的伯伯，早年下海经商成功，90年代就是百万富翁。 赚得多，自然在家族里面就有话语权。 老家的四合院，给鹏程的伯伯留的永远是最好的那一间，哪怕他并不经常回来住。 而鹏程一家三口，挤在潮湿的那面厢房里，还要负责保持鹏程伯伯那个房间的清洁。 鹏程小时候学习不好，托伯伯的帮助，才去了一所好学校。 但学校离老家远，鹏程不得不寄宿在伯伯家里。 伯伯倒没说啥，在家里管事的伯母却并不和善，总是找他的茬。 有一次，鹏程放学回来，伯母拉长了脸问他，家里的钱，是不是你拿的？ 鹏程愣了，连忙表示没有。 但伯母略过自己的孩子，硬说是鹏程来了之后，家里才陆陆续续丢钱。 末了，她还把鹏程爸和亲戚都叫来，当着大家的面说： 你们评评理，我供这孩子吃住，他还偷钱。老二，你赶紧把他带回去，别带坏了我的孩子。 鹏程爸只得押着鹏程过来道歉，在亲戚的指责声中对伯母点头哈腰，唯恐她真的要赶鹏程出去。 鹏程挺受刺激的，就此发奋读书，毕业后去了投资公司，后来趁电商兴起的风口自己成立了外贸公司，一路做到年入千万。 而伯伯家，传统的实业不好做了，生意大不如前。 他们家的孩子，一直悠哉悠哉地混日子。毕业了发现，家业惨淡，且呈现出不可挽回的颓势，而他们连工作都找不着。 这下，伯母提了几瓶好酒给鹏程的爸，恭恭敬敬地说了一堆好话，希望鹏程能给自己的孩子谋个职位。 我们赚钱并非为了对亲戚耀武扬威，而是为了争取多一点公平。 小时候，别人对你的态度，取决于你爸妈是谁。 长大后，别人对你爸妈的态度，取决于你是谁。 归根结底就是， 你能赚多少钱，他们走出去就会得到多少尊重。 虽然势利，但就是这么粗暴的生存法则。 我们生于其中，改变大局很难，改变自己的处境，反倒比较容易一点。 03 你赚多少钱，决定了亲家对你父母的态度 静秋是我们高中班长得最漂亮的女孩子。 当她和一个富二代在一起的时候，她爸妈却并不是很高兴。 她妈妈甚至说， 你嫁给人家，是要受苦的，我们作为娘家没什么钱，总归是会被他们看不起的。 静秋说，不会的，他爸妈都挺有教养的，不会做这种事。 确实，那个富二代的爸妈一开始并没有为难静秋，反倒让他们毕业了就早点结婚。 静秋觉得自己特别幸运，遇到了有钱而且人还不错的婆家，他们还二话不说就包揽了婚礼的全部费用。 但婚后，静秋爸妈送陪嫁的东西过来时，婆婆却说，亲家，你看我们这里啥也不缺，你把这些小家具带回去吧。 静秋爸妈说，这是给孩子结婚的的一点心意，放在新房里用。 静秋的婆婆说，你看，你买的家具，跟我们装修的新房，一点都不搭。家具我们会买，你们就带回去自己用吧。 平时，静秋的爸妈总是满怀诚意地送来家乡的土特产，静秋的婆婆收下后却从不拿出来吃，攒一堆之后，送回给老家的穷亲戚。 静秋的爸妈过来探望，家里多的是房间，静秋的婆婆却执意说要订酒店，说是酒店照顾比较周到。 结婚不久后，婆婆就催静秋生小孩，她说，你又不赚钱，趁年轻多生几个孩子，不然以后可怎么办？ 静秋这才恍然大悟，婆家一直把她当成一样漂亮的物品，买回家放着不亏的那种。 而她对这个物品保持着教养中的礼貌，却无法发自内心地尊重欣赏。 对于这个物品附带的静秋的爸妈，她也并不想过多来往。 小时候看偶像剧，平凡的女主角找到高富帅，父母激动不已，对他毕恭毕敬。 而高富帅的父母，对这种想攀高枝的小门小家，总是嗤之以鼻。 比嫁不成高富帅更让人痛苦的，是得不到尊重，甚至连累你的父母都得不到尊重。 结婚，要么娘家有钱，要么自己有钱才行。 如果家境普通，那么你只有多赚点钱，才不至于让父母被婆家轻视。 04 我们赚钱，是为了让父母家人过上更好的生活 我有一个朋友，研究生毕业时，她爸妈对她说，说实话，你考上研究生，让我们出门都很有面子。 于是，我朋友对我感慨道，原来，有时候，大人比小孩更虚荣。 不管这算不算虚荣，父母也有一大堆的人情世故，他们渴望在圈子里获得尊重，他们希望活得脸上有光，这是人之常情。 好的生活，就是有一些让别人羡慕的资本。 年轻的时候，他们拼自己。到老了，自己这一辈奋斗到头了，他们开始拼子女。 谁家要出一个学习好、赚钱多、婚姻幸福、孝顺的好孩子，不知要被多少人艳羡。 小时候，父母就算囊中羞涩，也会掏尽口袋里的钱，给我们买一部喜欢的MP3。 他们曾用尽全力，让我们在同学中不至于丢了面子。 如今，轮到我们，哪怕为了他们的那一点虚荣，也要与生活搏上一搏，多赚点钱。 你上班刷微博的时候，他们正在菜市场里挑挑拣拣，为了几毛钱与小贩磨破嘴皮； 你下班逛街的时候，他们正在喋喋不休地听邻居炫耀子女送的金手镯； 你过年收他们压岁钱的时候，别人的父母正跟着孩子去旅游； 你抱怨工作太累想求包养时，他们正省吃俭用给你凑房子首付。 你穷的时候，父母不敢病、不敢死，被别人嘲笑的时候，也无话反驳。 别再追求什么平凡可贵， 你赚多少钱，决定了别人对你父母的态度。 而他们最在乎的，就是在老年，对你能够放心之余，自己也能受到尊重。 作者：漫漫Chan链接：https://www.jianshu.com/p/c3aabd8e0834來源：简书 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"life","permalink":"http://jiubanmoli.github.io/categories/life/"}],"tags":[{"name":"人生感悟","slug":"人生感悟","permalink":"http://jiubanmoli.github.io/tags/人生感悟/"}]},{"title":"关于mybatis查询集合返回为[null]的问题","slug":"mybatis","date":"2018-06-18T09:19:25.593Z","updated":"2022-01-04T13:58:00.112Z","comments":true,"path":"2018/06/18/mybatis/","link":"","permalink":"http://jiubanmoli.github.io/2018/06/18/mybatis/","excerpt":"","text":"最近项目当中做功能遇到查询集合list为null，判非空却还是进入了非空的判断里面，后面才知道sql查询中 如果你是查询几个字段，必须加上不为空，否则sql查询前面的值是有值得，只是恰巧你查询的字段为Null document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://jiubanmoli.github.io/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://jiubanmoli.github.io/tags/mybatis/"}]},{"title":"20岁以后，要尽可能不被自己嫌弃","slug":"twenty","date":"2018-06-18T03:12:53.401Z","updated":"2022-01-04T13:58:00.153Z","comments":true,"path":"2018/06/18/twenty/","link":"","permalink":"http://jiubanmoli.github.io/2018/06/18/twenty/","excerpt":"","text":"人生，就是需要一个不断追逐的过程。 ❤ 越来越发现，身边有很多刚过20岁的90后开始喊老，不知道是跟随潮流自嘲，还是对20岁出头一事无成的自己表示失望。 总归好像是，人们好像都丢掉了本该在这个年龄所拥有的热血和激情，反而更多的是一种老气横秋的颓感，好像每个人都越来越嫌弃自己了。 周末跟小乐闲聊，说起近况的时候，她情绪突然变得很微妙。在我的追问下她告诉我说，想跟自己的好朋友绝交。 我问她为什么，她说，我跟她关系一直挺好的，经常一起上课一起吃饭，但是这学期开学的时候她就谈了个男朋友，然后就经常出去住，不过这倒也没什么，我也管不着，但是最重要的是她变太多了。以前特别努力的姑娘，现在却只会喊口号，变得很堕落，觉得她带给自己太多负能量了，很辛苦。 小乐这个朋友我多少知道一点，她以前跟我聊天经常会提起她，都是夸赞，但后来慢慢的就变成了吐槽。 她朋友家里条件应该不太好，有一个姐姐一个妹妹，还有一个弟弟，而且爸妈也是普通的工人阶级，生活挺拮据的，所以一开始她也很努力，天天泡图书馆，看网课学习，说要赚奖学金。 刚开始还好，可是到后来就变成化浓妆出去约会，经常逃课，考试也挂科，别说奖学金了，及格都很难。所以就有了天天发无数个朋友圈悲春伤秋的，嫌弃自己太颓废的，可事实呢？依然是天天疯玩，对待小乐给的建议也永远都是一脸嫌弃。 我让小乐趁早远离她，毕竟近朱者赤近墨者黑这句话并不是没有道理的，况且是这种听不进别人建议的人。 要知道，当一个人开始嫌弃自己的时候，至少说明他已经意识到自己所作所为的正确与否了，但如果只是一味嫌弃自己而不去做任何改变的时候，你可能需要远离这种人了。 一个迷途不知返的人是不值得你消耗感情的。你要做的是要尽可能不跟她走同一条路，不被自己嫌弃。 ❤ 前几天去超市的路上，夜夜突然发微信找我聊天，说有个好朋友把她删了，特别生气，特别闹心。 夜夜的朋友跟她是同班同学，从大一开始就经常腻在一起，虽然一开始两个人就性格不合，但倒也没有吵闹过，就想着搭个伴一起呗，反正日子总要过下去的。 可是她这个朋友呢，就属于那种见不得别人比她好的那种。夜夜搞个中分，她说，不好看，显脸大。她搞个刘海，她朋友又说，不适合你，你又不是那种萌妹子。总之她就是只会窝里横，仗着夜夜脾气好，整天对她冷嘲热讽。 夜夜很会写文章，而且现在是腾讯签约作家，她朋友多少也会眼红，各种泼冷水。就像有次夜夜穿了刚买的衣服去找她，她从上到下打量了一番，然后就开始跟旁边的同学偷笑，窃窃私语说些什么，还顺带着说了句“别跟她说”，夜夜听见她们在讨论说她衣服太透了，但是却不告诉她。 后来回到教室，她朋友在打王者荣耀，一直不停的骂着什么优秀的，好像是故意说给她听，有种指桑骂槐的感觉，夜夜听着挺不舒服的。 下课的时候，她朋友跟其他同学讨论衣服化妆品的时候，一直在吐槽说樊胜美太胖了，除了脸好看，身材一点都不好，可是她清楚的记得，就在前一天她还告诉夜夜，让她照着樊胜美的衣服去买，说她跟樊胜美身材像。 后来夜夜上选修课回来，改了个签“别指点我的生活，谢谢”，然后她就把夜夜的东西全部还回去，然后在qq上跟她说：从没想过指点你的生活，就这样，结束，随后就把她删了。 其实她应该庆幸她朋友把她删了，这样才不会拉低她朋友圈的整体档次。 好多人好像都有过被好朋友泼冷水的经历，也有那些各种见不到你好的所谓朋友，明明你是按照自己的想法在走，她却对你百般刁难各种嫌弃，最重要的是，她明明知道你比她优秀，却还总是故意在你面前展示她莫名的优越感。 也是，人越是没有什么越炫耀什么。 越长大，我们好像就越看中别人对我们的看法，越会想方设法想成为别人眼里优秀的样子。其实说实话，真没必要，做自己就好。 你都20多岁的人了，尽可能变得优秀不被自己嫌弃就好了，何必太过在意别人是否嫌弃你。 别人是只是别人，跟你没有任何关系，你只需要跟着自己的心，大胆往前走，努力朝自己喜欢的样子发展就好。 ❤ 想起我初中转学时同宿舍的一个妹子，叫李莹，她人就像她名字一样，很普通，普通到不说话都没有人意识到她的存在，可是也正是这种普通，让她骨子里的上进心显得格外夺目。 记得很清楚，我刚当插班生进班的那天，她是第一个跟我打招呼的人。她给我的第一感觉就是温暖，她笑起来特别好看，眼睛弯弯的，很可爱。后来我才知道，她是我们班的第一名。 我最佩服她的就是，说睡就睡，说起床就起床，说写不完作业不睡觉就绝对不会打瞌睡。印象最深的一次是，晚上十二点半，整个宿舍楼的人都睡觉的时候，她拉着我，抽出床底下的脸盆去水房洗头，而且是冷水。原因是太困了，现在想想当时我特么脑子肯定进水了陪她去，我又不困。 她是数学课代表，数学老师是个特别严肃的人，但是她深得数学老师的喜欢。一个原因就是她学习好，当然招老师喜欢，另一个原因大概就是她桀骜不驯的性格了，她谁都不怕，也能让别人服气，不论是学习成绩，还是做人做事。 她并不是特别谦虚的人，也经常被人泼冷水，但我看到更多的是她不服输的拼劲，好像潜意识里一直相信不能有人比她更优秀，当然她也做到了。 我一直欣赏那种特别看得起自己的人，那种人好像生来就自信感爆棚，不论别人再怎么打击，依然可以按照自己的方式骄傲的活着。 按照自己喜欢的方式过一生这句话几乎每个人都说过，但真正做到的，永远都只是那些疯狂前进的人，她们不会过多的在乎别人的看法，也不会一路莽撞前行，而是选择听从对自己有用的意见，抛弃那些负能量的冷嘲热讽，一路披荆斩棘，最终实现自我。 ❤ 世界上多的是见不得你好的人，但越是这样你越要过得比他们都好，这样才能不辜负那么好强的自己。 别人对你的看法只是别人眼里的你，你要做的不是成为别人眼里的样子，而是成为自己眼里的样子，成全自我。你要做的是自我满足，而不是按照别人的想法过一生。 你要尽可能让自己变得更好，尽可能不被自己嫌弃。 一直以来，都觉得20岁是人生很重要的一个分水岭，它比高中时期的你更成熟稳重，比步入社会的你更简单纯粹。 别人眼里的你千奇百怪，而你眼里只有一个你，那就是最真实的你。 永远都不要为了别人去改变自己，你要做的是朝着自己的目标努力，成全自己，相信自己。 你要做的，只是在面对诸多非议的时候，不用那么恐慌，不用想着取悦于他人，而是取悦于自己，尽可能不被自己嫌弃 作者：阿东哥哥链接：https://www.jianshu.com/p/87c0a2366f37來源：简书 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"life","permalink":"http://jiubanmoli.github.io/categories/life/"}],"tags":[{"name":"人生感悟","slug":"人生感悟","permalink":"http://jiubanmoli.github.io/tags/人生感悟/"},{"name":"20岁","slug":"20岁","permalink":"http://jiubanmoli.github.io/tags/20岁/"}]}]}